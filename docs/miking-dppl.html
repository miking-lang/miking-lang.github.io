<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">Miking DPPL | Miking</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="http://miking.org//docs/miking-dppl"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Miking DPPL | Miking"><meta data-react-helmet="true" name="description" content="Miking DPPL is a framework for developing probabilistic programming languages (PPLs) using Miking."><meta data-react-helmet="true" property="og:description" content="Miking DPPL is a framework for developing probabilistic programming languages (PPLs) using Miking."><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="http://miking.org//docs/miking-dppl"><link data-react-helmet="true" rel="alternate" href="http://miking.org//docs/miking-dppl" hreflang="en"><link data-react-helmet="true" rel="alternate" href="http://miking.org//docs/miking-dppl" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.20f232f7.css">
<link rel="preload" href="/assets/js/runtime~main.5fe202a0.js" as="script">
<link rel="preload" href="/assets/js/main.d2b2e899.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title">Miking</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/miking">Documentation</a><a class="navbar__item navbar__link" href="/publications">Publications</a><a class="navbar__item navbar__link" href="/workshop-2022">Workshop 2022</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/miking-lang/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/miking">Miking</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/miking-dppl">Miking DPPL</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_cwdi"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_xORG"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Miking DPPL</h1><p>Miking DPPL is a framework for developing probabilistic programming languages (PPLs) using <a href="https://github.com/miking-lang/miking" target="_blank" rel="noopener noreferrer">Miking</a>.
Currently, the framework includes the PPLs <a href="#coreppl">CorePPL</a> and <a href="#rootppl">RootPPL</a>.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="building-and-installing">Building and Installing<a class="hash-link" href="#building-and-installing" title="Direct link to heading">â€‹</a></h2><p>The main binary for development in Miking DPPL is called <code>cppl</code>. Currently, this binary is built by running <code>make</code> in the project root, and installed to <code>$HOME/.local/bin</code> with <code>make install</code> (uninstall is also possible through <code>make uninstall</code>). You must have <a href="https://github.com/miking-lang/miking" target="_blank" rel="noopener noreferrer">Miking</a> installed (the <code>mi</code> command must be globally available) to build <code>cppl</code>.
The command <code>make test</code> executes a set of tests for various components in the Miking DPPL framework.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="coreppl">CorePPL<a class="hash-link" href="#coreppl" title="Direct link to heading">â€‹</a></h2><p>CorePPL extends MExpr (see <a href="https://github.com/miking-lang/miking" target="_blank" rel="noopener noreferrer">Miking</a>) with probabilistic constructs for defining random variables and for likelihood updating. For example, the program</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">mexpr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x = assume (Beta 10.0 5.0) in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">observe true (Bernoulli x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>encodes a simple distribution for the bias of a coin, by setting a Beta prior for the probability of observing heads (i.e., <code>true</code>) for a single flip of the coin.</p><p>Defining random variables in CorePPL is done by providing a probability distribution to the <code>assume</code> construct.
Currently, there is no generated documentation for available distributions.</p><p>Likelihood updating is done through the <code>weight</code> and <code>observe</code> constructs.
With <code>weight</code>, the logarithm of the likelihood is updated directly (e.g., <code>weight (log 2)</code> multiplies the likelihood with 2).
With <code>observe</code>, the likelihood is instead updated with the value of the pmf or pdf for the given distribution at the given observation.
For example <code>observe true (Bernoulli 0.5)</code> updates the likelihood with a factor of 0.5.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="compiling-coreppl-to-mexpr">Compiling CorePPL to MExpr<a class="hash-link" href="#compiling-coreppl-to-mexpr" title="Direct link to heading">â€‹</a></h2><p>The default option for inferring the distribution encoded by a CorePPL program is to compile it to MExpr (which then compiles to OCaml).
You compile a CorePPL program <code>cpplprog.mc</code> using the command <code>cppl -m &lt;method&gt; cpplprog.mc</code>, where <code>&lt;method&gt;</code> is an inference algorithm prefixed with <code>mexpr-</code> (run the command <code>cppl</code> to see the current list of available algorithms).
For example, <code>cppl -m mexpr-importance cpplprog.mc</code> compiles <code>cpplprog.mc</code> to a binary file <code>out</code> which you can subsequently run to produce samples from the distribution encoded by <code>cpplprog.mc</code>:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">$ ./out 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-0.290110454733</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.80022937428 -0.222856874559</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.843424730606 -0.170284615588</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.80463734988 -0.217363600111</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.884065007231 -0.123224681456</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.660101541887 -0.415361604451</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.83498403869 -0.180342669655</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.430312010842 -0.84324472681</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.721170725777 -0.326879379468</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.675965445901 -0.391613319777</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0.826919003807 -0.190048528529</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The argument is the number of samples.
The first row prints the log of the normalizing constant, and the subsequent rows the samples.
The first column is the sample, and the second its log-weight.
For more help and options, run the <code>cppl</code> command without any arguments.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="implementing-new-inference-algorithms">Implementing New Inference Algorithms<a class="hash-link" href="#implementing-new-inference-algorithms" title="Direct link to heading">â€‹</a></h3><p>The CorePPL to MExpr compiler is organized to make it easy to implement new inference algorithms.
Currently, the best way to understand the framework is to look at the source code.
There are also some slides available at <code>coreppl/docs/coreppl-to-mexpr.pdf</code></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="compiling-coreppl-to-rootppl">Compiling CorePPL to RootPPL<a class="hash-link" href="#compiling-coreppl-to-rootppl" title="Direct link to heading">â€‹</a></h2><p>Another option to run inference over a CorePPL program is to compile it to RootPPL.
This option potentially results in more efficient inference (due to the efficiency of RootPPL), but also has quite a lot of limitations (for example, RootPPL does not support automatic memory management or higher-order functions).
A CorePPL program in a file <code>cpplprog.mc</code> can be compiled to a RootPPL file <code>out.cu</code> using the command <code>cppl -m rootppl-smc cpplprog.mc</code>.
The file <code>out.cu</code> can then be compiled using, e.g., <code>rootppl out.cu --stack_size 10000</code>.
The stack size option is mandatory for compiling RootPPL programs compiled from CorePPL.
More information about RootPPL can be found at <a href="#rootppl">RootPPL</a>.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="rootppl">RootPPL<a class="hash-link" href="#rootppl" title="Direct link to heading">â€‹</a></h2><p>RootPPL is an intermediate language for representing probabilistic models and comes with a framework that performs inference on the GPU in these models. See examples in the folder <code>rootppl/models</code>. The idea is that high-level Miking probabilistic programming languages should be compiled to this intermediate language.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="getting-started">Getting Started<a class="hash-link" href="#getting-started" title="Direct link to heading">â€‹</a></h3><p>The instructions below are tested on Ubuntu 18.04 but should work for other Unix-like systems.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="prerequisites">Prerequisites<a class="hash-link" href="#prerequisites" title="Direct link to heading">â€‹</a></h4><p>Before building RootPPL programs, a C++/CUDA compiler is required. RootPPL works on CPU and Nvidia GPU:s. For the CPU version, a C++ compiler should suffice, e.g. g++.  In
order to build for GPU, CUDA must be installed. See
CUDA installation guides: <a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/" target="_blank" rel="noopener noreferrer" title="CUDA Installation Guide Linux">Linux</a>,
<a href="https://docs.nvidia.com/cuda/cuda-installation-guide-mac-os-x/index.html" target="_blank" rel="noopener noreferrer" title="CUDA Installation Guide Mac">Mac</a>.</p><p>To run the CPU version in parallel, <a href="https://www.openmp.org/resources/openmp-compilers-tools/" target="_blank" rel="noopener noreferrer">OpenMP</a> must be installed.
OpenMP comes with recent gcc versions. However, OpenMP is not necessary if one does not want to execute programs in parallel on the CPU.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="install-rootppl">Install <code>rootppl</code><a class="hash-link" href="#install-rootppl" title="Direct link to heading">â€‹</a></h4><p>To install <code>rootppl</code> for the current user, first clone this repository and change directory to the <code>rootppl</code> folder. Then run:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">make install</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This will install <code>rootppl</code> to <code>$HOME/.local/bin</code> and inference engine sources to <code>$HOME/.local/src/rootppl</code>. Some systems, e.g. Mac OS, will require manually adding <code>$HOME/.local/bin</code> to <code>$PATH</code>.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="build">Build<a class="hash-link" href="#build" title="Direct link to heading">â€‹</a></h4><p>To compile a model and build an executable:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">rootppl path/to/model.cu</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This will compile the model along with the inference framework for CPU. The inference framework build products are placed under <code>build/</code>.
The <code>rootppl</code> command wraps <code>g++</code>/<code>nvcc</code>, and you may supply options used for <code>g++</code> and/or <code>nvcc</code> to <code>rootppl</code>.
These options will be used when compiling the supplied models, but not when compiling the inference framework.
One limitation is that it is currently only possible to supply source file(s) to <code>rootppl</code>.
Object/library files are not supported (for this, you must write your own custom build script).</p><p>To compile for GPU, add your GPU:s compute capability to the <code>--target</code> option.
You can find your GPU:s compute capability in the <a href="https://en.wikipedia.org/wiki/CUDA#GPUs_supported" target="_blank" rel="noopener noreferrer">Wikipedia table</a>.
Here is an example that will compile the airplane example for a GPU with a minimum compute capability of 7.5
(simply remove <code>--target sm_75</code> to compile for CPU):</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">rootppl models/airplane/airplane.cu --target sm_75 -j 5</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The optional argument <code>-j x</code> speeds up the compilation process by spawning <code>x</code> jobs, allowing for parallel compilation.
The corresponding parallel CPU (OpenMP) example is:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">rootppl models/airplane/airplane.cu --target omp -j 5</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Alternatively, the c++ compiler can be specified with CXX. This is often required on Mac OS to enable OpenMP, by using g++ instead of the default clang. On Mac OS, g++ can be installed with e.g. <code>brew install gcc</code>. Then, assuming the version installed was <code>gcc-10</code>:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">rootppl models/airplane/airplane.cu --target omp -j 5 --cxx g++-10</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The first build will compile the entire inference framework and can take 20 seconds or so when building for GPU. (Run <code>rootppl</code> with the <code>-j num_threads</code> to use multiple threads and speed up the build). The inference framework is recompiled whenever options such as <code>--target</code> are modified between runs of <code>rootppl</code>.</p><p>Any of the above commands should generate an executable named <code>a.out</code> (add <code>-o &lt;exec_name&gt;</code> to name it differently). Execute it with <code>./a.out num_particles</code>. For example:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">./a.out 1000</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>An example output of this:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">./a.out 1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-119.422143</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Num particles close to target: 98.9%, MinX: 56.2349, MaxX: 91.1572</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>First is the command that is executed, it executes the executable <code>a.out</code> with argument <code>1000</code>.
The first row is the normalizing constant. The second row is a print statement within the model.</p><p>You can supply a second argument to <code>a.out</code>, which is the number of sweeps:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">./a.out 1000 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-115.482724</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Num particles close to target: 89.7%, MinX: 51.5005, MaxX: 88.2039</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-115.472101</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Num particles close to target: 90.5%, MinX: 53.0577, MaxX: 90.0298</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-115.496258</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Num particles close to target: 88.7%, MinX: 48.1773, MaxX: 89.0957</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="creating-a-simple-model">Creating a simple model<a class="hash-link" href="#creating-a-simple-model" title="Direct link to heading">â€‹</a></h4><p>Models are divided into fragments to enable pausing the execution within models.
These fragments are functions referred to as basic blocks (<code>BBLOCK</code>).
To control the program execution flow, a program counter (<code>PC</code>) can be modified.
If it remains unchanged in when the basic block returns, resampling will be done, and then
the same block will be executed again. The program counter corresponds to the index of the basic block
to be executed. So, incrementing it means that the next block will be executed after resampling. An
example of this can be seen in the example below. However, if no following blocks are defined,
the inference will terminate as the model program has been executed.</p><p>Any interesting model will contain random choices, i.e. sampling from distributions.
Below is a coin flip example which flips a biased coin. <code>SAMPLE</code> is a macro that can take variable number of arguments.
First is the distribution name, followed by the distribution specific arguments.</p><p>Sampling is done differently on the CPU and the GPU,but these differences are hidden in the model with the help
of this <code>SAMPLE</code> macro. All of these RootPPL keywords are macros similar to <code>SAMPLE</code>, they provide higher-level
constructs that can be used in the same way regardless of if the model will be executed on the CPU or the GPU.</p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BBLOCK(coinFlip, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int coinSample = SAMPLE(bernoulli, 0.6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PC++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In the coin flip example above, there is one problem, however. The sample is only stored in a local
variable and is never used. To store data that remains when the next block is executed, the program
state (<code>PSTATE</code>) should be used. Before defining the blocks, the model must be
initialized with the macro <code>INIT_MODEL</code> that takes two arguments. First the type of the program
state (this could be any type, e.g. <code>int</code> or a structure), then the number of basic blocks in
the program. So, adding it to the above example:</p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">INIT_MODEL(int, 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BBLOCK(coinFlip, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PSTATE = SAMPLE(bernoulli, 0.6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PC++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now to run this program, only one thing remains to be defined, the main function.
This is done with the <code>MAIN</code> macro, taking a code block as argument.
The code below shows what we need in order to run the program and perform SMC.</p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">MAIN({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ADD_BBLOCK(coinFlip);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SMC(NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>First, the block must be added to the array of blocks to be executed. The order in which
blocks are added with <code>ADD_BLOCK</code>, defines their order in the array and thus
defines the order of execution together with the program counter. Secondly, the
<code>SMC</code> macro (its parameter is explained below) starts the inference.</p><p>Now the model can be compiled and executed! However, the result of the coin flips is
stored, but never used. To aggregate the results of all the particles&#x27; samples,
a callback function (<code>CALLBACK</code>) can be used. The callback will be called after
inference, but before clean up of the particles. This way, the results can be used to
generate desired distributions or values before particles are deleted.
Within the <code>CALLBACK</code> macro, the array of program states is accessed
with <code>PSTATES</code> and the number of particles is accessed with the
parameter <code>N</code> (which is hidden within the macro). Also, the log-weights array can be accessed with
the <code>WEIGHTS</code> macro. These weights are normalised (so that the exponent of these log-weights sum to 1).
Here is an example callback, called &quot;sampleMean&quot; that calculates and prints the mean
of the samples.</p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">CALLBACK(sampleMean, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double sum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int i = 0; i &lt; N; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum += PSTATES[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double mean = sum / N;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;Sample mean: %f\n&quot;, mean);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>For this to be used, the <code>SMC</code> macro call in main must be
changed to: <code>SMC(sampleMean);</code></p><p>This example can be found in
<a href="/docs/rootppl/models/simple-examples/coin_flip_mean.cu"><code>rootppl/models/simple-examples/coin_flip_mean.cu</code></a>
and, being in the <code>rootppl</code> directory, compiled with:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">rootppl models/simple-examples/coin_flip_mean.cu</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Then it can be executed with the executable followed by the
number of particles, for example: <code>./a.out 1000</code>.</p><p>An example output is then:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Sample mean: 0.608000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">log normalization constant = 0.000000</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>First we see our callback function&#x27;s output. Then on the next line, is the logarithm of the
normalization constant approximated by the inference. This is simply 0 here, since the model contains
no statements that alter the weights of the particles.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="supplementary-examples">Supplementary Examples<a class="hash-link" href="#supplementary-examples" title="Direct link to heading">â€‹</a></h4><p>Below follows some examples, these are all models that are defined within one single block.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="coin-flip-posterior">Coin Flip Posterior<a class="hash-link" href="#coin-flip-posterior" title="Direct link to heading">â€‹</a></h5><p>Full example: <a href="/docs/rootppl/models/simple-examples/coin_flip.cu"><code>rootppl/models/simple-examples/coin_flip.cu</code></a></p><p>In this model, a bias for a coin is sampled from the prior beta distribution. Then we observe that the coin flip is true. This model thus infers the
posterior distribution of the bias, conditioned on the observation.</p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BBLOCK(coinFlip, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double x = SAMPLE(beta, 2, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    OBSERVE(bernoulli, x, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PSTATE = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PC++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="gaussian-mixture-model">Gaussian Mixture Model<a class="hash-link" href="#gaussian-mixture-model" title="Direct link to heading">â€‹</a></h5><p>Full example: <a href="/docs/rootppl/models/simple-examples/mixture.cu"><code>rootppl/models/simple-examples/mixture.cu</code></a></p><p>This model demonstrates an example of <em>stochastic branching</em>, meaning that different code is executed depending on the outcome of the sample.</p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BBLOCK(mixture, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(SAMPLE(bernoulli, 0.7))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x = SAMPLE(normal, -2, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x = SAMPLE(normal, 3, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PSTATE = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PC++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="geometric-distribution-recursive">Geometric Distribution (Recursive)<a class="hash-link" href="#geometric-distribution-recursive" title="Direct link to heading">â€‹</a></h5><p>Full example: <a href="/docs/rootppl/models/simple-examples/geometric_recursive.cu"><code>rootppl/models/simple-examples/geometric_recursive.cu</code></a></p><p>This model combines stochastic branching with recursion. Basic blocks do not fully support recursion themselves, as they take no custom arguments or return values. Instead, a helper function is used to express the recursive model:</p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BBLOCK_HELPER(geometricRecursive, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(SAMPLE(bernoulli, p))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return BBLOCK_CALL(geometricRecursive, p) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}, int, double p)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BBLOCK(geometric, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PSTATE = BBLOCK_CALL(geometricRecursive, 0.6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PC++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that the helper function takes its return value and parameters comma-separated after the function body.</p><p>While recursive functions is supported by CUDA, iterative solutions are encouraged. Below is the same model, implemented with a loop instead.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="geometric-distribution-iterative">Geometric Distribution (Iterative)<a class="hash-link" href="#geometric-distribution-iterative" title="Direct link to heading">â€‹</a></h5><p>Full example: <a href="/docs/rootppl/models/simple-examples/geometric_iterative.cu"><code>rootppl/models/simple-examples/geometric_iterative.cu</code></a></p><div class="codeBlockContainer_I0IT language-CUDA theme-code-block"><div class="codeBlockContent_wNvx CUDA"><pre tabindex="0" class="prism-code language-CUDA codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">BBLOCK(geometric, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int numFlips = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(! SAMPLE(bernoulli, 0.6))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        numFlips++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PSTATE = numFlips;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PC++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="phylogenetic-models">Phylogenetic Models<a class="hash-link" href="#phylogenetic-models" title="Direct link to heading">â€‹</a></h4><p>More sophisticated models can be found in the <a href="/docs/rootppl/models/phylogenetics">phylogenetics directory</a>. These probabilistic
models to inference on observed phylogenetic trees. These observed trees can be found in <a href="/docs/rootppl/models/phylogenetics/tree-utils/trees.cuh">phylogenetics/tree-utils/trees.cuh</a>.
The correct phylogenetic models contain a link in the top of the file to the WebPPL source code used as reference when implementing them.
These models contain a number of new things, e.g.:</p><ul><li>Multiple basic blocks</li><li>Structures as program states</li><li>Recursive simulations</li><li>Global data used by the model</li><li>Resampling throughout the traversal of the observed tree</li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="constant-rate-birth-death">Constant-rate birth-death<a class="hash-link" href="#constant-rate-birth-death" title="Direct link to heading">â€‹</a></h5><p>In <a href="/docs/rootppl/models/phylogenetics/crbd">phylogenetics/crbd</a>, the constant-rate birth-death models can be found.
The most interesting file here is <a href="/docs/rootppl/models/phylogenetics/crbd/crbd.cu">crbd.cu</a> as it is a correct model
used by evolutionary biologists. This model uses a pre-processed DFS traversal path over the observed tree, rather than using a call stack.</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="further-phylogenetic-models">Further phylogenetic models<a class="hash-link" href="#further-phylogenetic-models" title="Direct link to heading">â€‹</a></h5><p>Further phylogenetic models are found in the package
<a href="https://github.com/vsenderov/phyrppl" target="_blank" rel="noopener noreferrer"><code>phyrppl</code></a>.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="the-rootppl-architecture">The RootPPL Architecture<a class="hash-link" href="#the-rootppl-architecture" title="Direct link to heading">â€‹</a></h4><p>The architecture&#x27;s main goal is to decouple the inference from the probabilistic models, this is the case for probabilistic
programming languages.
All inference engine code is located under <code>src/</code>.
In the <code>inference</code> directory, the code for inference methods can be found. Currently, only SMC is supported.
Within the <code>smc</code> directory, the <code>resampling</code> directory contain resampling strategies. Currently only Systematic Resampling is supported. The resampling has
a parallel implementation for the GPU, and a sequential and parallel implementation for the CPU.</p><ul><li>The <code>dists</code> directory contains distributions and scoring functions. Both models and inference can rely on these.</li><li>The <code>macros</code> directory contains all the macros/constructs that are mostly used by models but also in inference code.</li><li>The <code>utils</code> directory contains code that RootPPL uses, but can be used by models as well.</li><li>The <code>models</code> directory contains example models that use the inference.</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="compile-with-the-built-in-stack">Compile with the built-in stack<a class="hash-link" href="#compile-with-the-built-in-stack" title="Direct link to heading">â€‹</a></h4><p>To compile with the <code>progStateStack_t</code> program state, the macro <code>INIT_MODEL_STACK(num_bblocks)</code> should be used instead of <code>INIT_MODEL(progState_t, num_bblocks)</code>.
Then the stack size is specified in bytes with <code>--stack_size num_bytes</code>, e.g. <code>rootppl my_stack_model.cu --stack_size 10000</code>.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="building-a-more-interesting-model">Building a more interesting model<a class="hash-link" href="#building-a-more-interesting-model" title="Direct link to heading">â€‹</a></h4><p>TODO, stuff not yet demonstrated explicitly in README:</p><ul><li>WEIGHT macro</li><li>Multiple BBLOCK models</li><li>Global data accessible by bblocks on GPU</li><li>Program States containing more than a primitive datatype, e.g. structs.</li></ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/miking"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Miking</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#building-and-installing" class="table-of-contents__link toc-highlight">Building and Installing</a></li><li><a href="#coreppl" class="table-of-contents__link toc-highlight">CorePPL</a></li><li><a href="#compiling-coreppl-to-mexpr" class="table-of-contents__link toc-highlight">Compiling CorePPL to MExpr</a><ul><li><a href="#implementing-new-inference-algorithms" class="table-of-contents__link toc-highlight">Implementing New Inference Algorithms</a></li></ul></li><li><a href="#compiling-coreppl-to-rootppl" class="table-of-contents__link toc-highlight">Compiling CorePPL to RootPPL</a></li><li><a href="#rootppl" class="table-of-contents__link toc-highlight">RootPPL</a><ul><li><a href="#getting-started" class="table-of-contents__link toc-highlight">Getting Started</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/miking">Miking</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/miking-dppl">Miking DPPL</a></li></ul></div><div class="col footer__col"><div class="footer__title">Links</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/miking-lang/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 David Broman</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5fe202a0.js"></script>
<script src="/assets/js/main.d2b2e899.js"></script>
</body>
</html>