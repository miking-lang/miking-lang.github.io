import { DocBlock, Signature, Description, ToggleWrapper, S} from '@site/docs/Stdlib/MikingDocGen';
import Search from '@site/docs/Stdlib/Search';

<Search />
# ExtKCFA  
  

  
  
  
## Syntaxes  
  

          <DocBlock title="AbsVal" kind="syn">

```mc
syn AbsVal
```



<ToggleWrapper text="Code..">
```mc
syn AbsVal =
  -- Abstract representation of externals. Handled in a similar way as
  -- constants. We directly store the external arity in the abstract
  -- value. Note that ANF eta expands all external definitions, so from the
  -- perspective of CFA, externals are curried (need not be fully applied as in
  -- standard MExpr).
  -- NOTE(dlunde,2022-06-15): I'm not convinced the current approach for
  -- handling externals is optimal. The additional \\`let\\` added by ANF to shadow
  -- the original external definition is quite clunky. Maybe we can
  -- incorporate the fact that externals are always fully applied into the
  -- analysis somehow?
  | AVExt { ext: (IName,Ctx), arity: Int, args: [(IName,Ctx)] }
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="Constraint" kind="syn">

```mc
syn Constraint
```



<ToggleWrapper text="Code..">
```mc
syn Constraint =
  -- {ext args} ⊆ lhs ⇒ {ext args lhs} ⊆ res
  | CstrExtApp { lhs: (IName,Ctx),
                 rhs : (IName,Ctx),
                 res: (IName,Ctx) }
```
</ToggleWrapper>
</DocBlock>

## Semantics  
  

          <DocBlock title="absValToString" kind="sem">

```mc
sem absValToString : Index_IndexMap -> PprintEnv -> CFABase_AbsVal -> (PprintEnv, String)
```



<ToggleWrapper text="Code..">
```mc
sem absValToString im (env: PprintEnv) =
  | AVExt { ext = ext, args = args } ->
    -- We ignore the arity (one can simply look up the ext to get the arity)
    match mapAccumL (pprintVarINameCtx im) env args with (env,args) in
    let args = strJoin ", " args in
    match pprintVarINameCtx im env ext with (env,ext) in
    (env, join [ext, "(", args, ")"])
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="cmpAbsValH" kind="sem">

```mc
sem cmpAbsValH : (CFABase_AbsVal, CFABase_AbsVal) -> Int
```



<ToggleWrapper text="Code..">
```mc
sem cmpAbsValH =
  | (AVExt lhs, AVExt rhs) ->
    -- We ignore the arity (if ext is the same, arity is the same)
    let cmp = cmpINameCtx lhs.ext rhs.ext in
    if eqi 0 cmp then seqCmp cmpINameCtx lhs.args rhs.args
    else cmp
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="cmpConstraintH" kind="sem">

```mc
sem cmpConstraintH : (CFABase_Constraint, CFABase_Constraint) -> Int
```



<ToggleWrapper text="Code..">
```mc
sem cmpConstraintH =
  | (CstrExtApp { lhs = lhs1, rhs = rhs1, res = res1 },
     CstrExtApp { lhs = lhs2, rhs = rhs2, res = res2 }) ->
     let d = cmpINameCtx res1 res2 in
     if eqi d 0 then
       let d = cmpINameCtx lhs1 lhs2 in
       if eqi d 0 then cmpINameCtx rhs1 rhs2
       else d
     else d
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="initConstraint" kind="sem">

```mc
sem initConstraint : KCFA_CFAGraph -> CFABase_Constraint -> KCFA_CFAGraph
```



<ToggleWrapper text="Code..">
```mc
sem initConstraint (graph: CFAGraph) =
  | CstrExtApp r & cstr -> initConstraintName r.lhs graph cstr
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="propagateConstraint" kind="sem">

```mc
sem propagateConstraint : (IName, KCFA_Ctx, CFABase_AbsVal) -> KCFA_CFAGraph -> CFABase_Constraint -> KCFA_CFAGraph
```



<ToggleWrapper text="Code..">
```mc
sem propagateConstraint update graph =
  | CstrExtApp { lhs = lhs, rhs = rhs, res = res } ->
    match update.2
    with AVExt ({ ext = ext, args = args, arity = arity } & ave) then
      let args = snoc args rhs in
      if eqi arity (length args) then
        -- Last application
        -- TODO(dlunde,2022-06-15): We currently do nothing here. Optimally, we
        -- would like to delegate to a \\`propagateConstraintExt\\` here, similar
        -- to constants. I'm not sure where/how \\`propagateConstraintExt\\` should
        -- be defined.
        graph
      else
        -- Curried application, add the new argument
        addData graph (AVExt { ave with args = args }) res
    else graph
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="collectConstraints" kind="sem">

```mc
sem collectConstraints : KCFA_Ctx -> [KCFA_GenFun] -> KCFA_GenFunAcc -> Ast_Expr -> KCFA_GenFunAcc
```

<Description>{`This ensures that \`collectConstraints\` does \_not\_ try to collect constraints  
from \`let\`s immediately following externals. These \`let\`s are generated by  
the ANF transform and define eta expanded versions of the externals \(so  
that they can be curried\).`}</Description>


<ToggleWrapper text="Code..">
```mc
sem collectConstraints ctx cgfs acc =
  | TmDecl {decl = DeclExt _, inexpr = TmDecl {decl = DeclLet {ident = ident}, inexpr = inexpr}} & t ->
    let acc = foldl (lam acc. lam f.
        match acc with (env, cstrs) in
        match f ctx env t with (env, fcstrs) in
        (env, concat fcstrs cstrs)
      ) acc cgfs in
    collectConstraints ctx cgfs acc inexpr
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="generateConstraints" kind="sem">

```mc
sem generateConstraints : Index_IndexMap -> KCFA_Ctx -> KCFA_CtxEnv -> Ast_Expr -> KCFA_GenFunAcc
```



<ToggleWrapper text="Code..">
```mc
sem generateConstraints im ctx env =
  | TmDecl {decl = DeclExt _, inexpr = TmDecl {decl = DeclLet {ident = ident}, inexpr = inexpr}} ->
    -- NOTE(dlunde,2022-06-15): Currently, we do not generate any constraints
    -- for externals. Similarly to constants, we probably want to delegate to
    -- \\`generateConstraintsExts\\` here. As with \\`propagateConstraintExt\\`, it is
    -- not clear where the \\`generateConstraintsExts\\` function should be defined.
    --
    (env,[])
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="exprName" kind="sem">

```mc
sem exprName : Ast_Expr -> Name
```



<ToggleWrapper text="Code..">
```mc
sem exprName =
  -- Skip the eta expanded let added by ANF,
  | TmDecl {decl = DeclExt _, inexpr = TmDecl {decl = DeclLet _, inexpr = inexpr}} -> exprName inexpr
```
</ToggleWrapper>
</DocBlock>

