import { DocBlock, Signature, Description, ToggleWrapper, S} from '@site/docs/Stdlib/MikingDocGen';
import Search from '@site/docs/Stdlib/Search';

<Search />
# compile.mc  
  

The MLangCompiler compiles a \`MLangProgram\` into a single \`Expr\`.  
  
Before the MLangCompiler can be used to lower MLang to MExpr, the following  
transformations must have been performed \(in order\) as prerequisites:  
\(0\) All \`DeclInclude\`s must have been handled by \`include\-handler.mc\`.  
\(1\) All constants that have been parsed as TmVars should be transformed  
\-    into TmConst using \`const\-transformer.mc\`.  
\(2\) The LanguageComposer in \`language\-composer.mc\` must have been used  
    to generate syns and sems under langauge composition.  
\(3\) The entire MLangProgram must have been symbolized using \`symbolize.mc\`.  
\(4\) The MLangProgram must pass all of the conditions of valid composition  
    as checked by \`composition\-check.mc\`. Furthermore, the environment  
    that is generated by these checks must be passed to the compiler.  
  
The current compilation strategy can be summarized as follows:  
\(1\) MLang Decls with a corresponding construct in MExpr, are converted 1\-to\-1.  
    E.g. DeclLet, DeclRecLets, DeclConDef.  
\(2\) For each langauge fragment, a syntax declaration is turned into  
    a TmType if syntax definition is the base of this syntax and constructor  
    defintions are converted to TmConDefs.  
\(3\) All of the semantic functions in a Reclets are turned into a TmReclet.  
    The cases of a semantic functions are converted into a chain of TmMatch  
    expressions based on the orderning that computed in \`composition\-check.mc\`  
    We also perform subtitution on the name of semantic functions, arguments,  
    and type variables which are included from other language fragments.

  
  
## Stdlib Includes  
  
<a href={"/docs/Stdlib/mlang/ast.mc"} style={S.link}>ast.mc</a>, <a href={"/docs/Stdlib/mlang/ast-builder.mc"} style={S.link}>ast-builder.mc</a>, <a href={"/docs/Stdlib/mlang/pprint.mc"} style={S.link}>pprint.mc</a>, <a href={"/docs/Stdlib/mlang/symbolize.mc"} style={S.link}>symbolize.mc</a>, <a href={"/docs/Stdlib/mlang/composition-check.mc"} style={S.link}>composition-check.mc</a>, <a href={"/docs/Stdlib/mlang/language-composer.mc"} style={S.link}>language-composer.mc</a>, <a href={"/docs/Stdlib/mexpr/eval.mc"} style={S.link}>mexpr/eval.mc</a>, <a href={"/docs/Stdlib/mexpr/eq.mc"} style={S.link}>mexpr/eq.mc</a>, <a href={"/docs/Stdlib/mexpr/utils.mc"} style={S.link}>mexpr/utils.mc</a>, <a href={"/docs/Stdlib/common.mc"} style={S.link}>common.mc</a>, <a href={"/docs/Stdlib/option.mc"} style={S.link}>option.mc</a>, <a href={"/docs/Stdlib/map.mc"} style={S.link}>map.mc</a>, <a href={"/docs/Stdlib/bool.mc"} style={S.link}>bool.mc</a>, <a href={"/docs/Stdlib/name.mc"} style={S.link}>name.mc</a>, <a href={"/docs/Stdlib/error.mc"} style={S.link}>error.mc</a>, <a href={"/docs/Stdlib/set.mc"} style={S.link}>set.mc</a>, <a href={"/docs/Stdlib/result.mc"} style={S.link}>result.mc</a>  
  
## Types  
  

          <DocBlock title="CompilationContext" kind="type">

```mc
type CompilationContext : { decls: [Decl], toplevelDecls: [Decl], compositionCheckEnv: CompositionCheckEnv, semSymbols: Map String [Name], conToExtType: Map Name Name, allBaseSyns: Set Name, baseToCons: Map Name (Set Name), baseMap: Map Name Name, globalFields: Map Name Type }
```



<ToggleWrapper text="Code..">
```mc
type CompilationContext = use MLangAst in {
  -- Accumulator of compilation result
  decls: [Decl],

  -- Accumulator of expressions that must be at the top level
  -- I.e. declarations of open sum types and open product types.
  toplevelDecls : [Decl],

  compositionCheckEnv : CompositionCheckEnv,

  -- A map from identifier strings of semantic functions to the
  -- symbolized names that the function has in different fragments.
  semSymbols : Map String [Name],

  conToExtType : Map Name Name,

  allBaseSyns : Set Name,

  baseToCons : Map Name (Set Name),

  baseMap : Map Name Name,

  globalFields : Map Name Type
}
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="CompilationError" kind="type">

```mc
type CompilationError
```



<ToggleWrapper text="Code..">
```mc
type CompilationError
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="CompilationWarning" kind="type">

```mc
type CompilationWarning
```



<ToggleWrapper text="Code..">
```mc
type CompilationWarning
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="CompilationResult" kind="type">

```mc
type CompilationResult : Result CompilationWarning CompilationError CompilationContext
```



<ToggleWrapper text="Code..">
```mc
type CompilationResult = Result CompilationWarning CompilationError CompilationContext
```
</ToggleWrapper>
</DocBlock>

## Constructors  
  

          <DocBlock title="FoundIncludeError" kind="con">

```mc
con FoundIncludeError : { info: Info, path: String } -> CompilationError
```



<ToggleWrapper text="Code..">
```mc
con FoundIncludeError : {info : Info, path: String} -> CompilationError
```
</ToggleWrapper>
</DocBlock>

## Languages  
  

          <DocBlock title="DeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-DeclCompiler">

```mc
lang DeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang DeclCompiler = DeclAst + Ast + MExprSubstitute
  sem compileDecl : CompilationContext -> Decl -> CompilationResult
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="LetDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-LetDeclCompiler">

```mc
lang LetDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang LetDeclCompiler = DeclCompiler + LetDeclAst + LetDeclAst
  sem compileDecl ctx =
  | DeclLet d -> result.ok (
    withDecl ctx (DeclLet {ident = d.ident,
                         tyAnnot = d.tyAnnot,
                         tyBody = d.tyBody,
                         body = d.body,
                         info = d.info}))
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="RecletsDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-RecletsDeclCompiler">

```mc
lang RecletsDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang RecletsDeclCompiler = DeclCompiler + RecLetsDeclAst + RecLetsDeclAst
  sem compileDecl ctx =
  | DeclRecLets d -> result.ok (
    withDecl ctx (DeclRecLets {bindings = d.bindings,
                             info = d.info}))
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="UtestDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-UtestDeclCompiler">

```mc
lang UtestDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang UtestDeclCompiler = DeclCompiler + UtestDeclAst + UtestDeclAst
  sem compileDecl ctx =
  | DeclUtest d -> result.ok (
    withDecl ctx (DeclUtest {test = d.test,
                           expected = d.expected,
                           tusing = d.tusing,
                           tonfail = None (),
                           info = d.info}))
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="TypeDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-TypeDeclCompiler">

```mc
lang TypeDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang TypeDeclCompiler = DeclCompiler + TypeDeclAst + TypeDeclAst
  sem compileDecl ctx =
  | DeclType d ->
    result.ok (withDecl ctx (DeclType {ident = d.ident,
                                     params = d.params,
                                     tyIdent = d.tyIdent,
                                     info = d.info}))
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="ConDefDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-ConDefDeclCompiler">

```mc
lang ConDefDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang ConDefDeclCompiler = DeclCompiler + DataDeclAst + DataAst
  sem compileDecl ctx =
  | DeclConDef d -> result.ok (
    withDecl ctx (DeclConDef {ident = d.ident,
                            tyIdent = d.tyIdent,
                            info = d.info}))
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="ExtDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-ExtDeclCompiler">

```mc
lang ExtDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang ExtDeclCompiler = DeclCompiler + ExtDeclAst + ExtDeclAst
  sem compileDecl ctx =
  -- TODO(voorberg, 2024-04-23): Add test case for the compilation of externals.
  | DeclExt d -> result.ok (
    withDecl ctx (DeclExt {ident = d.ident,
                         tyIdent = d.tyIdent,
                         effect = d.effect,
                         info = d.info}))
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="SynTypeDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-SynTypeDeclCompiler">

```mc
lang SynTypeDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang SynTypeDeclCompiler = SynDeclAst + TypeDeclAst
  sem compileSynType : CompilationContext -> Decl -> CompilationContext
  sem compileSynType ctx =
  | DeclSyn s ->
    -- We only include a type definition if this is the base declaration of
    -- a syntax type. To check that something is a base syn definition,
    -- we check that it does not include any other definitions.
    if null s.includes then
      withTopLevelDecl ctx (DeclType {ident = s.ident,
                                    params = s.params,
                                    tyIdent = tyvariant_ [],
                                    info = s.info})
    else
      ctx
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="SemDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-SemDeclCompiler">

```mc
lang SemDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang SemDeclCompiler = SemDeclAst + MExprAst + DeclCompiler
  sem compileSem langStr ctx semNames =
  | DeclSem d ->
    -- If this semantic function does not have a type annotation, copy the
    -- type annotation from the base semantic function.
    let baseIdent = (match mapLookup (langStr, nameGetStr d.ident) ctx.compositionCheckEnv.baseMap with Some ident in ident) in
    let baseTyAnnot = match mapLookup baseIdent ctx.compositionCheckEnv.semBaseToTyAnnot with Some ty in ty in
    let tyAnnot = match d.tyAnnot with TyUnknown _ then baseTyAnnot else d.tyAnnot in

    -- Create substitution function for param aliasing
    let args = match d.args with Some args then args else [] in
    let argsIdents : [Name] = map (lam a. a.ident) args in

    let targetName = nameSym "target" in
    let target = nvar_ targetName in

    recursive
      let compileBody = lam cases : [{pat : Pat, thn : Expr}].
        match cases with [h] ++ t then
          TmMatch {target = target,
                   pat = h.pat,
                   thn = h.thn,
                   els = compileBody t,
                   ty = tyunknown_,
                   info = d.info}
        -- else (error_ (str_ "Inexhaustive match!"))
        else
          let s = join ["Inexhaustive match in ", langStr, ".", nameGetStr d.ident, "!\n"] in
          semi_ (print_ (str_ s)) (inever_ d.info)
    in
    let compileBodyHelper = lam cases : [{pat : Pat, thn : Expr}].
      if null cases then
        error_ (str_ (join ["Semantic function without cases: ", langStr, ".", nameGetStr d.ident, "!\n"]))
      else
        compileBody cases
    in
    let cases = match mapLookup (langStr, nameGetStr d.ident) ctx.compositionCheckEnv.semPatMap
                with Some x then x
                else error "CompositionCheckEnv must contain the ordered cases for all semantic functions!"
    in

    let curTyVarSymbols = match mapLookup (langStr, nameGetStr d.ident) ctx.compositionCheckEnv.semTyVarMap with Some ns in ns in

    -- Substitute parameters, sem symbols and type variables.
    --
    -- We substitute the parameters because semantic functions are allowed
    -- to have different parameter names than the sems they include as long
    -- as the amount of parameters is the same (this is checked by
    -- composition-check.mc). To handle the case in which the parameter names
    -- are different, we must perform a substitution.
    --
    -- For any included cases, we look at the origin language of this case. Any
    -- sem names belonging to the origin language are substituted to the name
    -- of the language fragment we are compiling. We do not just substitute the
    -- name of the current sem, but of all sems in the langauge fragment in order
    -- to properly handle mutual recursion.
    --
    -- Since semantic funtions can have different type annotations introducing
    -- different symbols, and these symbols may be used in the case bodies,
    -- we also substitute these symbols.
    let work = lam c.
      let origArgs : Option [Name] = match mapLookup c.orig ctx.compositionCheckEnv.semArgsMap with Some args in args in
      let origArgs : [Name] = match origArgs with Some args then args else [] in

      let origTyVarSymbols = match mapLookup c.orig ctx.compositionCheckEnv.semTyVarMap with Some ns in ns in

      let pairs = join [
        zip origArgs argsIdents,
        createPairsForSubst ctx c.orig.0 langStr,
        zip origTyVarSymbols curTyVarSymbols
      ] in

      let subst = mapFromSeq nameCmp pairs in
      {c with thn = substituteIdentifiersExpr subst c.thn} in
    let cases = map work cases in

    let cases = map (lam c. {thn = c.thn, pat = c.pat}) cases in
    let body = compileBodyHelper cases in
    recursive let compileArgs = lam args.
          match args with [h] ++ t then
            TmLam {ident = h.ident,
                   tyAnnot = h.tyAnnot,
                   tyParam = tyunknown_,
                   body = compileArgs t,
                   ty = tyunknown_,
                   info = d.info}
          else
            TmLam {ident = targetName,
                   tyAnnot = tyunknown_,
                   tyParam = tyunknown_,
                   body = body,
                   ty = tyunknown_,
                   info = d.info}
    in
    let result = compileArgs (optionGetOrElse (lam. []) d.args) in
    match d.args with Some _ then
      {ident = d.ident,
      tyAnnot = tyAnnot,
      tyBody = tyunknown_,
      body = result,
      info = d.info}
    else
      {ident = d.ident,
      tyAnnot = tyAnnot,
      tyBody = tyunknown_,
      body = (nulam_ (nameSym "") (error_ (str_ (join ["Semantic function without cases!: ", langStr, ".", nameGetStr d.ident])))),
      info = d.info}
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="MLangSynDefCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-MLangSynDefCompiler">

```mc
lang MLangSynDefCompiler
```



<ToggleWrapper text="Code..">
```mc
lang MLangSynDefCompiler = SynDeclAst + MExprAst
  sem compileMLangSynDefs langStr ctx =
  | DeclSyn s ->
    match mapLookup (langStr, nameGetStr s.ident) ctx.compositionCheckEnv.baseMap
    with Some baseIdent in

    -- Wrap a type in a tyall for each parameter
    let forallWrapper = lam ty. foldr ntyall_ ty s.params in

    -- Apply the type variables to the type constructor on the rhs of tyIdent
    let rhs = foldl (lam ty. lam n. tyapp_ ty (ntyvar_ n)) (ntycon_ baseIdent) s.params in

    let compileDef = lam ctx. lam def.
      withDecl ctx (DeclConDef {ident = def.ident,
                              tyIdent = forallWrapper (tyarrow_ def.tyIdent rhs),
                              info = s.info}) in

    foldl compileDef ctx s.defs
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="MLangLangDeclCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-MLangLangDeclCompiler">

```mc
lang MLangLangDeclCompiler
```



<ToggleWrapper text="Code..">
```mc
lang MLangLangDeclCompiler = DeclCompiler + LangDeclAst + MExprAst + SemDeclAst +
                             SynDeclAst + TypeDeclAst + SynTypeDeclCompiler +
                             SemDeclCompiler + MLangSynDefCompiler
  sem compileDecl ctx =
  | DeclLang l ->
    let langStr = nameGetStr l.ident in

    let typeDecls = filter isTypeDecl l.decls in
    let synDecls = filter isSynDecl l.decls in
    let semDecls = filter isSemDecl l.decls in

    let nameSeq =  (map (lam s. match s with DeclSem s in (nameGetStr s.ident, s.ident)) semDecls) in
    let semNames = mapFromSeq cmpString nameSeq in

    let ctx = foldl withSemSymbol ctx (map (lam s. match s with DeclSem s in s.ident) semDecls) in

    let ctx = foldl compileSynType ctx synDecls in
    let res = result.foldlM compileDecl ctx typeDecls in
    let res = result.map (lam ctx. foldl (compileMLangSynDefs langStr) ctx synDecls) res in

    let compileSemToResult : CompilationContext -> [Decl] -> CompilationContext
      = lam ctx. lam sems.
        let semBindings = map (compileSem langStr ctx semNames) sems in
        withDecl ctx (DeclRecLets {bindings = semBindings,
                                 info = l.info})
    in
    result.map (lam ctx. compileSemToResult ctx semDecls) res
  | DeclSyn s ->
    error "Unexpected DeclSyn"
  | DeclSem s ->
    error "Unexpected DeclSem!"
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="MLangTopLevelCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-MLangTopLevelCompiler">

```mc
lang MLangTopLevelCompiler
```



<ToggleWrapper text="Code..">
```mc
lang MLangTopLevelCompiler = MLangTopLevel + DeclCompiler + LangDeclAst + SynDeclAst
  sem _gatherBaseSemNames : Set Name -> Decl -> Set Name
  sem _gatherBaseSemNames acc =
  | DeclLang d ->
    foldl _gatherBaseSemNames acc d.decls
  | DeclSyn {includes = [], ident = ident} ->
    setInsert ident acc
  | _ -> acc


  sem compileProg : CompilationContext -> MLangProgram -> Result CompilationWarning CompilationError (CompilationContext, Expr)
  sem compileProg ctx =
  | prog ->
    let ctx = {ctx with allBaseSyns = foldl _gatherBaseSemNames (setEmpty nameCmp) prog.decls} in

    let res = result.foldlM compileDecl ctx prog.decls in
    result.map (lam ctx. (ctx, prog.expr)) res
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="MLangCompilerWihtoutLang" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-MLangCompilerWihtoutLang">

```mc
lang MLangCompilerWihtoutLang
```



<ToggleWrapper text="Code..">
```mc
lang MLangCompilerWihtoutLang = MLangAst + MExprAst + MLangTopLevelCompiler +
                                ExtDeclCompiler + ConDefDeclCompiler +
                                TypeDeclCompiler + UtestDeclCompiler +
                                RecletsDeclCompiler + LetDeclCompiler
  sem compile : CompilationContext -> MLangProgram -> Result CompilationWarning CompilationError Expr
  sem compile ctx =| prog ->
    match result.consume (compileProg ctx prog) with (_, res) in
    switch res
      case Left err then
        result.err (head err)
      case Right (ctx, expr) then
        result.ok (bindall_ (concat ctx.toplevelDecls ctx.decls) expr)
    end
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="MLangCompiler" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-MLangCompiler">

```mc
lang MLangCompiler
```



<ToggleWrapper text="Code..">
```mc
lang MLangCompiler = MLangCompilerWihtoutLang + MLangLangDeclCompiler
end
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="TestLang" kind="lang" link="/docs/Stdlib/mlang/compile.mc/lang-TestLang">

```mc
lang TestLang
```



<ToggleWrapper text="Code..">
```mc
lang TestLang = MLangCompiler + MLangSym + MLangCompositionCheck +
                MExprPrettyPrint + MExprEval + MExprEq end
```
</ToggleWrapper>
</DocBlock>

## Variables  
  

          <DocBlock title="data_" kind="let">

```mc
let data_ ident : Name -> Ast_Kind
```



<ToggleWrapper text="Code..">
```mc
let data_ = lam ident : Name.
  use DataKindAst in
  let types = mapEmpty nameCmp in
  let types = mapInsert ident {lower = setEmpty nameCmp, upper = None ()} types in
  Data {types = types}
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="mergeRecordTypes" kind="let">

```mc
let mergeRecordTypes l r : Ast_Type -> Ast_Type -> Ast_Type
```



<ToggleWrapper text="Code..">
```mc
let mergeRecordTypes = lam l. lam r.
  use RecordTypeAst in
  match (l, r) with (TyRecord left, TyRecord right) in
  TyRecord {left with fields = mapUnion left.fields right.fields}
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="_emptyCompilationContext" kind="let">

```mc
let _emptyCompilationContext env : CompositionCheckEnv -> CompilationContext
```



<ToggleWrapper text="Code..">
```mc
let _emptyCompilationContext : CompositionCheckEnv -> CompilationContext =
  lam env : CompositionCheckEnv. {
    decls = [],
    toplevelDecls = [],
    compositionCheckEnv = env,
    semSymbols = mapEmpty cmpString,
    conToExtType = mapEmpty nameCmp,
    allBaseSyns = setEmpty nameCmp,
    baseToCons = mapEmpty nameCmp,
    baseMap = mapEmpty nameCmp,
    globalFields = mapEmpty nameCmp
}
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="withDecl" kind="let">

```mc
let withDecl ctx decl : CompilationContext -> Ast_Decl -> CompilationContext
```



<ToggleWrapper text="Code..">
```mc
let withDecl = lam ctx. lam decl.
  {ctx with decls = snoc ctx.decls decl}
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="withTopLevelDecl" kind="let">

```mc
let withTopLevelDecl ctx decl : CompilationContext -> Ast_Decl -> CompilationContext
```



<ToggleWrapper text="Code..">
```mc
let withTopLevelDecl = lam ctx. lam decl.
  {ctx with toplevelDecls = snoc ctx.toplevelDecls decl}
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="withSemSymbol" kind="let">

```mc
let withSemSymbol ctx n : CompilationContext -> Name -> CompilationContext
```



<ToggleWrapper text="Code..">
```mc
let withSemSymbol = lam ctx : CompilationContext. lam n : Name.
  let s = nameGetStr n in
  let newValue = match mapLookup s ctx.semSymbols with Some names
                 then cons n names
                 else [n]
  in
  {ctx with semSymbols = mapInsert s newValue ctx.semSymbols}
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="createPairsForSubst" kind="let">

```mc
let createPairsForSubst env origLang targetLang : CompilationContext -> String -> String -> [(Name, Name)]
```



<ToggleWrapper text="Code..">
```mc
let createPairsForSubst = lam env. lam origLang. lam targetLang.
  match mapLookup origLang env.compositionCheckEnv.langToSems with Some origNames in
  match mapLookup targetLang env.compositionCheckEnv.langToSems with Some targetNames in

  let origSet = setOfSeq nameCmp origNames in
  let targetPairs = map (lam n. (nameGetStr n, n)) targetNames in
  let targetMap = mapFromSeq cmpString targetPairs in

  let origs = setToSeq origSet in

  map (lam n. (n, match mapLookup (nameGetStr n) targetMap with Some x in x)) origs
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="isTypeDecl" kind="let">

```mc
let isTypeDecl d : Ast_Decl -> Bool
```



<ToggleWrapper text="Code..">
```mc
let isTypeDecl = use MLangAst in
  lam d. match d with DeclType _ then true else false
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="isSynDecl" kind="let">

```mc
let isSynDecl d : Ast_Decl -> Bool
```



<ToggleWrapper text="Code..">
```mc
let isSynDecl = use MLangAst in
  lam d. match d with DeclSyn _ then true else false
```
</ToggleWrapper>
</DocBlock>


          <DocBlock title="isSemDecl" kind="let">

```mc
let isSemDecl d : Ast_Decl -> Bool
```



<ToggleWrapper text="Code..">
```mc
let isSemDecl = use MLangAst in
  lam d. match d with DeclSem _ then true else false
```
</ToggleWrapper>
</DocBlock>

## Mexpr  
  

          <DocBlock title="mexpr" kind="mexpr">

```mc
mexpr
```



<ToggleWrapper text="Code..">
```mc
mexpr
use TestLang in
use LanguageComposer in

let simpleEval = lam e. eval (evalCtxEmpty ()) e in

let testCompile = lam p.
  let p = composeProgram p in
  match symbolizeMLang symEnvDefault p with (_, p) in
  match result.consume (checkComposition p) with (_, res) in

  match res with Left errs then (use MLangCompositionCheck in iter raiseError errs; never )
  else match res with Right env in
  let ctx = _emptyCompilationContext env in
  let res = result.consume (compile ctx p) in
  match res with (_, rhs) in
  match rhs with Right expr in expr
in

let testError = lam p.
  match symbolizeMLang symEnvDefault p with (_, p) in
  match result.consume (checkComposition p) with (_, res) in
  match res with Right env in
  let ctx = _emptyCompilationContext env in
  let res = result.consume (compile ctx p) in
  match res with (_, rhs) in
  match rhs with Left errs in errs
in

let testEval = lam p.
  simpleEval (testCompile p)
in

-- Test simple let binding
let p : MLangProgram = {
    decls = [
        ulet_ "x" (int_ 1)
    ],
    expr = var_ "x"
} in
utest testEval p with int_ 1 using eqExpr in

-- Test recursive let bindings through mutually recursive odd/even
let odd = (ulam_ "x"
  (if_
    (eqi_ (var_ "x") (int_ 0))
    (false_)
    (appf1_ (var_ "even") (subi_ (var_ "x") (int_ 1)))))
in
let even = (ulam_ "x"
  (if_
    (eqi_ (var_ "x") (int_ 0))
    (true_)
    (appf1_ (var_ "odd") (subi_ (var_ "x") (int_ 1)))))
in
let p : MLangProgram = {
    decls = [
        ureclets_ [("odd", odd), ("even", even)]
    ],
    expr = appf1_ (var_ "odd") (int_ 9)
} in
utest testEval p with true_ using eqExpr in
let p : MLangProgram = {
    decls = [
        ureclets_ [("odd", odd), ("even", even)]
    ],
    expr = appf1_ (var_ "odd") (int_ 10)
} in
utest testEval p with false_ using eqExpr in

-- Test Utest
let p : MLangProgram = {
    decls = [
        utest_ (int_ 3) (addi_ (int_ 1) (int_ 2))
    ],
    expr = uunit_
} in
let expected : Expr = bind_ (utest_ (int_ 3) (addi_ (int_ 1) (int_ 2))) uunit_ in
utest testCompile p with expected using eqExpr in

-- Test Declype and DeclConDef
let p : MLangProgram = {
    decls = [
      type_ "Foo" [] (tyvariant_ []),
      condef_ "Bar"
        (tyarrow_ tyint_ (tycon_ "Foo"))
      ],
    expr = matchex_
      (conapp_ "Bar" (int_ 1))
      (pcon_ "Bar" (pvar_ "x"))
      (addi_ (var_ "x") (int_ 1))
} in
let res = testCompile p in
utest testEval p with int_ 2 using eqExpr in

-- Test basic semantic function
let p : MLangProgram = {
    decls = [
        decl_lang_ "L1" [
            decl_sem_
                "f"
                [("x", tyint_)]
                [(pvar_ "y", addi_ (var_ "x") (var_ "y"))]
        ]
    ],
    expr = bind_ (use_ "L1") (appf2_ (var_ "f") (int_ 10) (int_ 20))
} in
utest testEval p with int_ 30 using eqExpr in

-- Test semantic function with pattern that must be ordered
-- Since the 2nd pattern is a strict subset of the first,
-- the first pattern is checked first and only if this is not a match
-- do we fall through to the first pattern.
let fsem = decl_sem_ "f" [] [(por_ (pint_ 1) (pint_ 2), int_ -1),
                             (pint_ 2, int_ 1)]
in
let p : MLangProgram = {
    decls = [
        decl_lang_ "L1" [fsem]
    ],
    expr = bind_ (use_ "L1") (appf1_ (var_ "f") (int_ 2))
} in
utest testEval p with int_ 1 using eqExpr in

let p : MLangProgram = {
    decls = [
        decl_lang_ "L1" [fsem]
    ],
    expr = bind_ (use_ "L1") (appf1_ (var_ "f") (int_ 1))
} in
utest testEval p with int_ -1 using eqExpr in

-- Test DeclSyn and DeclSem using a small arithmetic language
let exprSyn = decl_syn_ "Expr" [("IntExpr", tyint_),
                                ("AddExpr", tytuple_ [tycon_ "Expr", tycon_ "Expr"])] in
let evalSem = decl_sem_ "eval" [] [(pcon_ "IntExpr" (pvar_ "i"), var_ "i"),
                                   (pcon_ "AddExpr" (ptuple_ [pvar_ "lhs", pvar_ "rhs"]),
                                    addi_ (appf1_ (var_ "eval") (var_ "lhs")) (appf1_ (var_ "eval") (var_ "rhs")))] in

let p : MLangProgram = {
    decls = [
        decl_lang_ "MyIntArith" [exprSyn, evalSem]
    ],
    expr = bind_ (use_ "MyIntArith")
                 (appf1_ (var_ "eval")
                         (conapp_ "AddExpr" (utuple_ [(conapp_ "IntExpr" (int_ 40)),
                                                      (conapp_ "IntExpr" (int_ 2))])))
} in
utest testEval p with int_ 42 using eqExpr in

-- Test Sum Extension
let baseSyn = decl_syn_ "Expr" [("IntExpr", tyint_),
                                ("AddExpr", tytuple_ [tycon_ "Expr", tycon_ "Expr"])] in
let baseSem = decl_sem_ "eval" [] [(pcon_ "IntExpr" (pvar_ "i"), var_ "i"),
                                   (pcon_ "AddExpr" (ptuple_ [pvar_ "lhs", pvar_ "rhs"]),
                                    addi_ (appf1_ (var_ "eval") (var_ "lhs")) (appf1_ (var_ "eval") (var_ "rhs")))] in
let sugarSyn = decl_syn_ext_ "Expr" [("IncrExpr", tycon_ "Expr")] in
let sugarEval = decl_sem_ext_ "eval" [] [(pcon_ "IncrExpr" (pvar_ "e"), addi_ (int_ 1) (appf1_ (var_ "eval") (var_ "e")))] in
let p : MLangProgram = {
    decls = [
        decl_lang_ "MyIntArith" [baseSyn, baseSem],
        decl_langi_ "SugaredIntArith" ["MyIntArith"] [sugarSyn, sugarEval]
    ],
    expr = bind_ (use_ "SugaredIntArith")
                 (appf1_ (var_ "eval")
                         (conapp_ "IncrExpr" (conapp_ "AddExpr" (utuple_ [(conapp_ "IntExpr" (int_ 20)),
                                                      (conapp_ "IntExpr" (int_ 2))]))))
} in
utest testEval p with int_ 23 using eqExpr in

let p : MLangProgram = {
    decls = [
        decl_lang_ "MyIntArith" [baseSyn, baseSem],
        decl_langi_ "SugaredIntArith" ["MyIntArith"] [sugarSyn, sugarEval]
    ],
    expr = bind_ (use_ "SugaredIntArith")
                 (appf1_ (var_ "eval")
                         (conapp_ "AddExpr" (utuple_ [(conapp_ "IncrExpr" (conapp_ "IntExpr" (int_ 21))),
                                                      (conapp_ "IntExpr" (int_ 1))])))
} in
utest testEval p with int_ 23 using eqExpr in

-- Test semantic function with different paremeter names
let p : MLangProgram = {
    decls = [
        decl_lang_ "L0" [
          decl_sem_ "f" [("x", tyunknown_)] [(pint_ 0, var_ "x")]
        ],
        decl_langi_ "L1" ["L0"] [
          decl_sem_ext_ "f" [("y", tyunknown_)] [(pint_ 1, muli_ (int_ -1) (var_ "y"))]
        ]
    ],
    expr = bind_ (use_ "L1")
                 (addi_ ((appf2_ (var_ "f") (int_ 10) (int_ 0)))
                        ((appf2_ (var_ "f") (int_ 10) (int_ 1))))
} in
utest testEval p with int_ 0 using eqExpr in

-- Test language composition under quantified type variables
let p : MLangProgram = {
    decls = [
        decl_lang_ "L0" [
          decl_semty_cases_
            "f"
            (tyall_ "a" (tyarrow_ (tyvar_ "a") (tyvar_ "a")))
            [(pvar_ "x", bind_ (let_ "y" (tyvar_ "a") (var_ "x")) (var_ "y"))]
        ],
        decl_langi_ "L1" ["L0"] []
    ],
    expr = bind_ (use_ "L1") (appf1_ (var_ "f") (int_ 0))
} in
utest testEval p with int_ 0 using eqExpr in

-- Test language composition is correctly renaming bound recursive functions.
let decls = [
  decl_lang_ "L0" [
    decl_sem_
      "isodd"
      []
      [(pvar_ "x", if_ (eqi_ (int_ 0) (var_ "x")) false_ (appf1_ (var_ "iseven") (subi_ (var_ "x") (int_ 1))))],
    decl_sem_
      "iseven"
      []
      []
  ],
  decl_langi_ "L1" ["L0"] [
    decl_sem_ext_
      "iseven"
      []
      [(pvar_ "x", if_ (eqi_ (int_ 0) (var_ "x")) true_ (appf1_ (var_ "isodd") (subi_ (var_ "x") (int_ 1))))]
  ]
] in
let p : MLangProgram = {
    decls = decls,
    expr = bind_ (use_ "L1") (appf1_ (var_ "iseven") (int_ 12))
} in
utest testEval p with true_ using eqExpr in
let p : MLangProgram = {
    decls = decls,
    expr = bind_ (use_ "L1") (appf1_ (var_ "iseven") (int_ 11))
} in
utest testEval p with false_ using eqExpr in
()
```
</ToggleWrapper>
</DocBlock>

