"use strict";(self.webpackChunkmiking_lang_github_io=self.webpackChunkmiking_lang_github_io||[]).push([[160],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,h=u["".concat(s,".").concat(c)]||u[c]||m[c]||r;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4685:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return u}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={sidebar_position:1,id:"miking"},s="Miking",p={unversionedId:"miking",id:"miking",title:"Miking",description:"Miking (Meta vIKING) is a meta language system for creating embedded domain-specific and general-purpose languages. Miking is not a programming language, but rather a language system for",source:"@site/docs/miking-remote.md",sourceDirName:".",slug:"/miking",permalink:"/docs/miking",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,id:"miking"},sidebar:"tutorialSidebar",next:{title:"Miking DPPL",permalink:"/docs/miking-dppl"}},d=[{value:"Getting started",id:"getting-started",children:[{value:"The REPL",id:"the-repl",children:[],level:3}],level:2},{value:"Editor Support",id:"editor-support",children:[],level:2},{value:"MCore",id:"mcore",children:[],level:2},{value:"MExpr",id:"mexpr",children:[{value:"Unit Test Expressions",id:"unit-test-expressions",children:[],level:3},{value:"Intrinsics",id:"intrinsics",children:[],level:3},{value:"Let Expressions",id:"let-expressions",children:[],level:3},{value:"Functions",id:"functions",children:[],level:3},{value:"Sequencing",id:"sequencing",children:[],level:3},{value:"<code>if</code> Expressions",id:"if-expressions",children:[],level:3},{value:"Recursion",id:"recursion",children:[],level:3},{value:"Tuples",id:"tuples",children:[],level:3},{value:"Records",id:"records",children:[],level:3},{value:"Data Types and <code>match</code> expressions",id:"data-types-and-match-expressions",children:[],level:3},{value:"Pattern matching",id:"pattern-matching",children:[],level:3},{value:"Sequences",id:"sequences",children:[],level:3},{value:"Tensors",id:"tensors",children:[],level:3},{value:"References",id:"references",children:[],level:3}],level:2},{value:"MLang",id:"mlang",children:[{value:"Top-Level Definitions and Includes",id:"top-level-definitions-and-includes",children:[],level:3},{value:"Language Fragments",id:"language-fragments",children:[],level:3},{value:"Known Issues/Future Work",id:"known-issuesfuture-work",children:[],level:3}],level:2},{value:"Externals (builtin)",id:"externals-builtin",children:[{value:"Python",id:"python",children:[{value:"Usage",id:"usage",children:[],level:4},{value:"Conversion between MCore and Python",id:"conversion-between-mcore-and-python",children:[{value:"From MCore to Python",id:"from-mcore-to-python",children:[],level:5},{value:"From Python to MCore",id:"from-python-to-mcore",children:[],level:5}],level:4}],level:3}],level:2},{value:"Externals",id:"externals",children:[{value:"Conversion between values",id:"conversion-between-values",children:[],level:3},{value:"Sundials",id:"sundials",children:[],level:3},{value:"Ipopt",id:"ipopt",children:[],level:3},{value:"External Dependent Utests Pruning",id:"external-dependent-utests-pruning",children:[{value:"Selective pruning",id:"selective-pruning",children:[],level:4},{value:"Test organization",id:"test-organization",children:[],level:4},{value:"Authoring new external libraries",id:"authoring-new-external-libraries",children:[],level:4}],level:3},{value:"Parallel Programming",id:"parallel-programming",children:[{value:"Atomic References",id:"atomic-references",children:[],level:4},{value:"Multi-Threaded Execution",id:"multi-threaded-execution",children:[],level:4},{value:"Synchronization",id:"synchronization",children:[],level:4}],level:3},{value:"Probability distributions",id:"probability-distributions",children:[],level:3}],level:2},{value:"Profiling",id:"profiling",children:[{value:"Profiling output",id:"profiling-output",children:[{value:"Output format",id:"output-format",children:[],level:4},{value:"Postprocessing",id:"postprocessing",children:[],level:4}],level:3},{value:"Notes",id:"notes",children:[],level:3}],level:2},{value:"Acceleration",id:"acceleration",children:[{value:"Accelerate backends",id:"accelerate-backends",children:[],level:3},{value:"Usage",id:"usage-1",children:[{value:"Recommended workflow",id:"recommended-workflow",children:[],level:4},{value:"Example",id:"example",children:[],level:4}],level:3},{value:"Sequence sizes",id:"sequence-sizes",children:[{value:"Size coercions",id:"size-coercions",children:[],level:4},{value:"Size equality",id:"size-equality",children:[],level:4}],level:3},{value:"Limitations",id:"limitations",children:[],level:3}],level:2},{value:"Auto Tuning",id:"auto-tuning",children:[{value:"Context-Dependent Holes",id:"context-dependent-holes",children:[],level:3}],level:2},{value:"Contributing",id:"contributing",children:[{value:"Setup and use <code>ocamlformat</code>",id:"setup-and-use-ocamlformat",children:[],level:3},{value:"Git Blame",id:"git-blame",children:[],level:3}],level:2},{value:"MIT License",id:"mit-license",children:[],level:2}],m={toc:d};function u(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"miking"},"Miking"),(0,r.kt)("p",null,"Miking (Meta vIKING) is a meta language system for creating embedded domain-specific and general-purpose languages. Miking is not a programming language, but rather a language system for\ncreating languages and generating efficient compilers."),(0,r.kt)("h2",{id:"getting-started"},"Getting started"),(0,r.kt)("p",null,"Before you can use the Miking system, you need to install\n",(0,r.kt)("a",{parentName:"p",href:"https://ocaml.org/"},"OCaml")," and the\n",(0,r.kt)("a",{parentName:"p",href:"https://opam.ocaml.org/"},"OPAM")," package manager."),(0,r.kt)("p",null,"After the installation, you need to install the OCaml compiler by\nrunning the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam update\nopam switch create miking-ocaml 5.0.0~rc1\neval $(opam env)\n")),(0,r.kt)("p",null,"After this, you need to install the ",(0,r.kt)("inlineCode",{parentName:"p"},"opam")," packages ",(0,r.kt)("inlineCode",{parentName:"p"},"dune")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"linenoise")," by\nrunning the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam install dune linenoise\n")),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"opam switch")," command lets you have several OCaml installations on\nyour system. When using the Miking system, you need to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"miking-ocaml"),"\nswitch. Running ",(0,r.kt)("inlineCode",{parentName:"p"},"opam switch miking-ocaml")," followed by ",(0,r.kt)("inlineCode",{parentName:"p"},"eval $(opam env)"),"\nalways takes you back to the correct switch."),(0,r.kt)("p",null,"To compile the project, go back to the Miking repository and execute:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make\n")),(0,r.kt)("p",null,"This creates two binaries in the ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," directory: ",(0,r.kt)("inlineCode",{parentName:"p"},"build/boot")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"build/mi"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"build/boot")," is the bootstrap interpreter, and ",(0,r.kt)("inlineCode",{parentName:"p"},"build/mi"),"\nis the main Miking executable, containing both an interpreter and a\ncompiler. You will mainly be using ",(0,r.kt)("inlineCode",{parentName:"p"},"mi"),", but ",(0,r.kt)("inlineCode",{parentName:"p"},"boot")," provides a few\nfeatures not yet available in the main executable, such as a REPL."),(0,r.kt)("p",null,"To run tests checking that everything has been installed correctly,\nuse"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make test\n")),(0,r.kt)("p",null,"Alternatively, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"make test-all")," to run the full test suite. Beware\nthat this may take some time. Alternatively you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"make\ntest-all-prune-utests")," which will exclude tests whose external dependencies are\nnot met on the current system (with the exception of ",(0,r.kt)("inlineCode",{parentName:"p"},"pyml"),")."),(0,r.kt)("p",null,"To run a hello world program, create a file ",(0,r.kt)("inlineCode",{parentName:"p"},"hello.mc")," with the following code,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'mexpr print "Hello world!\\n"\n')),(0,r.kt)("p",null,"and then run it using the command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"build/mi hello.mc\n")),(0,r.kt)("p",null,"To help Miking find its standard library, you should define the\nenvironment variable ",(0,r.kt)("inlineCode",{parentName:"p"},"MCORE_STDLIB")," to be the path to ",(0,r.kt)("inlineCode",{parentName:"p"},"stdlib"),",\nfor example by running the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cd stdlib; export MCORE_STDLIB=`pwd`; cd ..;\n")),(0,r.kt)("p",null,"To install the compiler along with the standard library for the current\nuser, issue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make install\n")),(0,r.kt)("p",null,"This will install ",(0,r.kt)("inlineCode",{parentName:"p"},"mi")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"$HOME/.local/bin")," and the standard library to ",(0,r.kt)("inlineCode",{parentName:"p"},"$HOME/.local/lib/mcore/stdlib"),", according to the ",(0,r.kt)("a",{parentName:"p",href:"https://www.freedesktop.org/software/systemd/man/file-hierarchy.html"},"systemd file system hierarchy overview"),". If ",(0,r.kt)("inlineCode",{parentName:"p"},"MCORE_STDLIB")," is unset, Miking will look in this installation folder as its default library location."),(0,r.kt)("p",null,"Conversely, to uninstall, issue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make uninstall\n")),(0,r.kt)("h3",{id:"the-repl"},"The REPL"),(0,r.kt)("p",null,"The Miking bootstrap interpreter features a simple REPL, which lets\nyou interactively execute fragments of MCore code. Both toplevel\ndefinitions and expressions can be evaluated."),(0,r.kt)("p",null,"To start the REPL (assuming that the interpreter is installed in the path), run"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"boot repl\n")),(0,r.kt)("p",null,"The following is an example interaction with the REPL."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Welcome to the MCore REPL!\nType :h for help or :q to quit.\n>> let x = 5\n>> let y = 10 in\n | addi x y\n15\n>>\n")),(0,r.kt)("h2",{id:"editor-support"},"Editor Support"),(0,r.kt)("p",null,"It is possible to write Miking code in any editor and compile it\nvia the command line. There are, however, editing modes for a\nnumber of editors:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/miking-lang/miking-emacs"},"Emacs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/miking-lang/miking-vim"},"Vim")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/miking-lang/miking-sublime-text"},"Sublime"))),(0,r.kt)("p",null,"If you create an editing mode of your own, please send a pull\nrequest to update this list!"),(0,r.kt)("h2",{id:"mcore"},"MCore"),(0,r.kt)("p",null,"MCore (Miking Core) is the core language of the Miking system. It is\nbased on a typed Lambda Calculus (Note: the type system is under\ndevelopment, and the current implementation is untyped)."),(0,r.kt)("p",null,"MCore consists of two parts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"MExpr")," is an MCore expression. A Miking language is always translated into an MExpr, before it is further evaluated or compiled into machine code.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"MLang")," which is a language for defining and composing language fragments. MLang is formally translated into an MExpr."))),(0,r.kt)("h2",{id:"mexpr"},"MExpr"),(0,r.kt)("p",null,"One design objective of MExpr is to make the concrete syntax very close to the abstract syntax of the language. That is, no syntactic sugar is introduced to the concrete MCore syntax. The MExpr language is not intended to be a general-purpose programming language. Instead, the aim of MCore is to be a core language that other languages can translate into."),(0,r.kt)("p",null,"Nevertheless, to understand the Miking system, it is a good idea to learn to write basic programs directly as MCore expressions."),(0,r.kt)("p",null,"In the end, an MCore file ",(0,r.kt)("inlineCode",{parentName:"p"},".mc")," is always translated into an MCore expression. If an MCore file contains ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr 5"),", it means that the final expression of the program is value ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),". That is, ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr")," states the start of the program and is followed by the actual MExpr of the program. If the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr")," is left out of the file, a default mexpr unit value ",(0,r.kt)("inlineCode",{parentName:"p"},"()")," is the resulting value."),(0,r.kt)("h3",{id:"unit-test-expressions"},"Unit Test Expressions"),(0,r.kt)("p",null,"When writing MCore programs, it is typically done by writing explicit unit tests as part of the code. For instance"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mexpr\nutest addi 1 2 with 3 in\n()\n")),(0,r.kt)("p",null,"checks that the addition of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," is in fact ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),". To run the tests in an ",(0,r.kt)("inlineCode",{parentName:"p"},".mc")," file, run the ",(0,r.kt)("inlineCode",{parentName:"p"},"mi")," command with argument ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," (assuming that you have now installed ",(0,r.kt)("inlineCode",{parentName:"p"},"mi")," in your path):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mi run program.mc --test\n")),(0,r.kt)("p",null,"Typically when you develop MCore programs, you do not use the ",(0,r.kt)("inlineCode",{parentName:"p"},"print")," function. Instead, you write unit tests directly and then leave the units tests as is directly after your function. By doing so, you test your code, write regression tests, and document the informal semantics of your program directly. We strongly encourage you to develop your MCore programs this way."),(0,r.kt)("p",null,"In the rest of this document, we omit the ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr")," keyword for brevity, and just write the MExpr itself. Remember to add it as appropriate when trying the various examples."),(0,r.kt)("h3",{id:"intrinsics"},"Intrinsics"),(0,r.kt)("p",null,"MCore contains a number of built-in values (intrinsics) and\npredefined functions and constants (part of the standard library).\nFor instance,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'print "Hello\\n"\n')),(0,r.kt)("p",null,"uses the built-in function ",(0,r.kt)("inlineCode",{parentName:"p"},"print")," which has the type ",(0,r.kt)("inlineCode",{parentName:"p"},"String -> ()"),", i.e., it prints a string and returns the unit type."),(0,r.kt)("p",null,"The current documentation of intrinsics is implicit via code\ncontaining ",(0,r.kt)("inlineCode",{parentName:"p"},"utest")," expressions. Please see the following files:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/bool-test.mc"},"Boolean intrinsics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/int-test.mc"},"Integer intrinsics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/float-test.mc"},"Floating-point number intrinsics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/string-test.mc"},"Strings intrinsics "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/seq-test.mc"},"Sequences intrinsics "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/effects.mc"},"Side effect (printing, I/O, debugging etc.) intrinsics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/symbs.mc"},"Symbol intrinsics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/references.mc"},"Reference intrinsics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/random-test.mc"},"Random number generation intrinsics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"test/mexpr/time.mc"},"Time intrinsics")))),(0,r.kt)("h3",{id:"let-expressions"},"Let Expressions"),(0,r.kt)("p",null,"Expressions can be given names using ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expressions. For instance"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let x = addi 1 2 in\nx\n")),(0,r.kt)("p",null,"introduces a new name ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),". The built-in function ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," performs an addition between two integers. Note that MCore uses a call-by-value evaluation order, which means that expressions are evaluated into a value before they are applied to a function or substituted using a ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expression. Hence, the expression ",(0,r.kt)("inlineCode",{parentName:"p"},"addi 1 2")," is evaluated before it is substituted for ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," in the rest of the expression."),(0,r.kt)("h3",{id:"functions"},"Functions"),(0,r.kt)("p",null,"Functions are always defined anonymously as lambda functions. If you would like to give a function a name, a ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expression can be used. For instance, the following program defines a function ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," that doubles the value of its argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let double = lam x. muli x 2 in\nutest double 5 with 10 in\n()\n")),(0,r.kt)("p",null,"Types can be expressed in MCore programs, but they are currently not checked. For instance, the ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," function can be written as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let double = lam x:Int. muli x 2 in\n")),(0,r.kt)("p",null,"This means that ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," has type ",(0,r.kt)("inlineCode",{parentName:"p"},"Int -> Int"),", which can also be expressed as part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expression."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let double : Int -> Int = lam x. muli x 2 in\n")),(0,r.kt)("p",null,"A function with several parameters are expressed using currying, using nested lambda expressions. For instance, expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let foo = lam x. lam y. addi x y in\nutest foo 2 3 with 5 in\n()\n")),(0,r.kt)("p",null,"creates a function ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," that takes two arguments."),(0,r.kt)("p",null,"A lambda can also be defined without a variable, e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"lam. e"),", where\n",(0,r.kt)("inlineCode",{parentName:"p"},"e")," is some expression representing the body of the function. Such\nnotation is useful if the actual variable is not used inside ",(0,r.kt)("inlineCode",{parentName:"p"},"e"),". Note\nthat ",(0,r.kt)("inlineCode",{parentName:"p"},"lam. e")," is syntactic sugar for a normal lambda ",(0,r.kt)("inlineCode",{parentName:"p"},'lam #var"". e'),",\nwhere the identifier of the variable name is the empty identifier."),(0,r.kt)("h3",{id:"sequencing"},"Sequencing"),(0,r.kt)("p",null,"Sometimes an expression has a side effect and you are not interested\nin the returned value. If that is the case, you can use the sequence\noperator ",(0,r.kt)("inlineCode",{parentName:"p"},";"),". For instance, suppose you would like to print a value in\na function before it returns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let foo = lam x.\n  print x;\n  x\n")),(0,r.kt)("p",null,"The sequence operator ",(0,r.kt)("inlineCode",{parentName:"p"},";")," is not a construct of pure MExpr, but\nsyntactic sugar for a ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," construct. For instance, the pure version\n(without syntactic sugar) of the program above is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'let foo = lam x.\n  let #var"" = print x in\n  x\n')),(0,r.kt)("p",null,"Note that a variable with an empty identifier is used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expression. Moreover, note that a ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let _ = foo x in ...\n")),(0,r.kt)("p",null,"is syntactically not valid since ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expressions always bind a value to a variable. Underscore ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," is a pattern and patterns are only allowed in ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," expressions."),(0,r.kt)("h3",{id:"if-expressions"},(0,r.kt)("inlineCode",{parentName:"h3"},"if")," Expressions"),(0,r.kt)("p",null,"Conditional expressions can be expressed using ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," expressions. The program"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'let x = 5 in\nlet answer = if (lti x 10) then "yes" else "no" in\nutest answer with "yes" in\n()\n')),(0,r.kt)("p",null,"checks if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is less than 10 (using the ",(0,r.kt)("inlineCode",{parentName:"p"},"lti")," function with signature ",(0,r.kt)("inlineCode",{parentName:"p"},"Int -> Int -> Bool"),"). If it is true, the string ",(0,r.kt)("inlineCode",{parentName:"p"},'"yes"')," is returned, else string ",(0,r.kt)("inlineCode",{parentName:"p"},'"no"')," is returned."),(0,r.kt)("p",null,"Note that an ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," expression is not a construct in pure MExpr. It is syntactic sugar for a ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," expression. That is, the expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"if x then e1 else e2\n")),(0,r.kt)("p",null,"is translated into"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"match x with true then e1 else e2\n")),(0,r.kt)("h3",{id:"recursion"},"Recursion"),(0,r.kt)("p",null,"A normal ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expression cannot be used to define recursive functions. Instead, recursion can be defined using ",(0,r.kt)("em",{parentName:"p"},"recursive lets"),", starting with the ",(0,r.kt)("inlineCode",{parentName:"p"},"recursive")," keyword:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"recursive\nlet fact = lam n.\n  if eqi n 0\n    then 1\n    else muli n (fact (subi n 1))\nin\n\nutest fact 0 with 1 in\nutest fact 4 with 24 in\n()\n\n")),(0,r.kt)("p",null,"Recursive lets can also be used to define mutually recursive functions. For instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"recursive\nlet odd = lam n.\n    if eqi n 1 then true\n    else if lti n 1 then false\n    else even (subi n 1)\nlet even = lam n.\n    if eqi n 0 then true\n    else if lti n 0 then false\n    else odd (subi n 1)\nin\n\nutest odd 4 with false in\nutest even 4 with true in\n")),(0,r.kt)("h3",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"Product types can be expressed using tuples. An n-tuple is defined using syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"(e_1, ..., e_n)")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"e_1")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"e_n")," are MCore expressions. Extracting a value from a tuple (projection) is performed using an expression ",(0,r.kt)("inlineCode",{parentName:"p"},"e.n")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," is the expression that is evaluated into a tuple, and ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is an integer number representing the index of an element in the tuple. The first index in a tuple is ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,r.kt)("p",null,"For instance, in the MCore expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'let t = (addi 1 2, "hi", 80) in\nutest t.0 with 3 in\nutest t.1 with "hi" in\nutest t.2 with 80 in\n()\n')),(0,r.kt)("p",null,"we create a 3-tuple ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," and project out its values. Note that the different elements of a tuple can have different types. In this case, tuple ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," has type ",(0,r.kt)("inlineCode",{parentName:"p"},"(Int, String, Int)"),"."),(0,r.kt)("p",null,"Singleton tuples are also supported: ",(0,r.kt)("inlineCode",{parentName:"p"},"(x,)")," represents a tuple with ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," as its\nonly element."),(0,r.kt)("h3",{id:"records"},"Records"),(0,r.kt)("p",null,"Another more general form of product types are records. A record has\nnamed fields that can have different types. For instance,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'let r1 = {age = 42, name = "foobar"} in\n')),(0,r.kt)("p",null,"defines a record of type ",(0,r.kt)("inlineCode",{parentName:"p"},"{age : int, name : string}"),". The order of the fields does not matter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest r1 with {age = 42, name = "foobar"} in\nutest r1 with {name = "foobar", age = 42} in\n')),(0,r.kt)("p",null,"To project out a value, a dot notation may be used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest r1.age with 42 in\nutest r1.name with "foobar" in\n()\n')),(0,r.kt)("p",null,"A record type is not just a general product type in MCore, it is the only\nproduct type. That is, a tuple is just ",(0,r.kt)("em",{parentName:"p"},"syntactic sugar")," for a record. This means that the compiler encodes a tuple as a record, where the names of the fields are numbers ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),", etc. Labels can internally be any kind of string. For strings that cannot be defined as a normal identifier, the label form ",(0,r.kt)("inlineCode",{parentName:"p"},'#label"x"'),"\ncan be used, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is the string of the label."),(0,r.kt)("p",null,"The following example shows how a tuple is actually encoded as a\nrecord."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest ("foo",5) with {#label"0" = "foo", #label"1" = 5} in ()\n')),(0,r.kt)("h3",{id:"data-types-and-match-expressions"},"Data Types and ",(0,r.kt)("inlineCode",{parentName:"h3"},"match")," expressions"),(0,r.kt)("p",null,"Sum types or variant types are constructed using ",(0,r.kt)("inlineCode",{parentName:"p"},"con")," expressions (constructor expressions). In contrast to most other functional languages, the introduction of a new data type and the introduction of constructors are separated. For instance, the expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"type Tree in\ncon Node : (Tree,Tree) -> Tree in\ncon Leaf : (Int) -> Tree in\n")),(0,r.kt)("p",null,"introduces a new data type ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," and defines two new constructors ",(0,r.kt)("inlineCode",{parentName:"p"},"Node")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Leaf"),". Constructor ",(0,r.kt)("inlineCode",{parentName:"p"},"Leaf")," takes just one argument (an integer value for the leaf) and returns a tree, whereas the ",(0,r.kt)("inlineCode",{parentName:"p"},"Node")," constructor takes a tuple with two trees as input and constructs a new tree node."),(0,r.kt)("p",null,"For instance, the expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let tree = Node(Node(Leaf 4, Leaf 2), Leaf 3) in\n")),(0,r.kt)("p",null,"is a small tree named ",(0,r.kt)("inlineCode",{parentName:"p"},"tree"),"."),(0,r.kt)("p",null,"Assume now that we want to count the sum of the values of all leafs in a tree. We can then write a recursive function that performs the counting."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'recursive\n  let count = lam tree.\n    match tree with Node t then\n      let left = t.0 in\n      let right = t.1 in\n      addi (count left) (count right)\n    else match tree with Leaf v then v\n    else error "Unknown node"\nin\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," expression inside the count function ",(0,r.kt)("em",{parentName:"p"},"deconstructs")," data values by matching against a given constructor. For instance, the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"match tree with Node t then expr1 else expr2\n")),(0,r.kt)("p",null,"matches the value after evaluating expression ",(0,r.kt)("inlineCode",{parentName:"p"},"tree")," and checks if its outer most constructor is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Node")," constructor. If that is the case, the identifier ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," in expression ",(0,r.kt)("inlineCode",{parentName:"p"},"expr1")," is bound to the tuple consisting of the node's two sub trees (recall the definition of the constructor ",(0,r.kt)("inlineCode",{parentName:"p"},"Node"),"). Finally, if we execute the test"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest count tree with 9 in ()\n")),(0,r.kt)("p",null,"we can check that the function computes the result as intended."),(0,r.kt)("h3",{id:"pattern-matching"},"Pattern matching"),(0,r.kt)("p",null,"In the previous match example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," construct matched against\nthe constructor, but not against the actual data content. MExpr is\ndesigned to be simple with few language constructs, at the right level\nof abstraction. If the abstraction level is too low, it is hard to\nperform useful static analysis and code generation. As a consequence,\nMExpr support ",(0,r.kt)("em",{parentName:"p"},"patterns")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," expressions. The ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," function\ncan be rewritten as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'recursive\n  let count = lam tree.\n    match tree with Node(left,right) then\n      addi (count left) (count right)\n    else match tree with Leaf v then v\n    else error "Unknown node"\nin\n')),(0,r.kt)("p",null,"where the match construct matches against pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"Node(left,right)"),",\nwhere ",(0,r.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"right")," are pattern variables."),(0,r.kt)("p",null,"Remember, however, that tuples are just syntactic sugar for records. Hence, match line"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    match tree with Node(left,right) then\n")),(0,r.kt)("p",null,"is equivalent to the following"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'    match tree with Node {#label"0"=left,#label"1"=right} then\n')),(0,r.kt)("p",null,"where the pattern is a ",(0,r.kt)("em",{parentName:"p"},"record pattern"),"."),(0,r.kt)("p",null,"Pattern matching is the general form of deconstructing data in MExpr. Patterns can also be nested:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest\n  match {foo=7,bar={more="hello"}} with {foo=_,bar={more=str}} then str else ""\nwith "hello" in\n')),(0,r.kt)("p",null,"Note also the use of ",(0,r.kt)("em",{parentName:"p"},"wildcard")," patterns ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," (used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),"\nfield), which matches any value."),(0,r.kt)("p",null,"Finally, MExpr also supports more advanced patterns, including ",(0,r.kt)("inlineCode",{parentName:"p"},"AND")," patterns (using infix notation ",(0,r.kt)("inlineCode",{parentName:"p"},"&"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest match (1, 2) with (a, _) & b then (a, b) else (0, (0, 0)) with (1, (1, 2)) in\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"OR")," patterns (using infix notation ",(0,r.kt)("inlineCode",{parentName:"p"},"|"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest match K1 1 with K1 a | K2 a | K3 a then a else 0 with 1 in\n")),(0,r.kt)("p",null,"and ",(0,r.kt)("inlineCode",{parentName:"p"},"NOT")," patterns (using the prefix notation ",(0,r.kt)("inlineCode",{parentName:"p"},"!"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest match Some true with a & !(None ()) then a else Some false with Some true in\nutest match None () with a & !(None ()) then a else Some false with Some false in\n\n")),(0,r.kt)("p",null,"These are present to make it possible to translate order-dependent patterns to order-",(0,r.kt)("em",{parentName:"p"},"in"),"dependent patterns. For example, in OCaml,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"match (opt1, opt2) with\n| (Some a, _) -> a\n| (_, Some a) -> a\n| (_, _) -> 1\n")),(0,r.kt)("p",null,"is order-dependent; any change in pattern order changes which match-arm is executed. To express this in an order-independent manner we ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," every pattern with the inverse (",(0,r.kt)("inlineCode",{parentName:"p"},"!"),") of the union (",(0,r.kt)("inlineCode",{parentName:"p"},"|"),") of the previous patterns. If we pretend for a moment that OCaml supports ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," in patterns they could then be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"match (opt1, opt2) with\n| (Some a, _) -> a\n| (_, Some a) & !(Some a, _) -> a\n| (_, _) & !((Some a, _) | (_, Some a))-> 1\n")),(0,r.kt)("p",null,"The order can now be changed freely without affecting the semantics. In practice ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," will probably rarely be used in manually written code, while ",(0,r.kt)("inlineCode",{parentName:"p"},"|")," is rather more useful."),(0,r.kt)("h3",{id:"sequences"},"Sequences"),(0,r.kt)("p",null,"An MCore sequence is constructed using syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"[e_1, ..., e_n]"),". All elements in a sequence must have the same type. For instance, an expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[1,3,6,7,22,3]\n")),(0,r.kt)("p",null,"has type ",(0,r.kt)("inlineCode",{parentName:"p"},"[Int]")," whereas and expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'["this", "is", "a", "test"]\n')),(0,r.kt)("p",null,"has type ",(0,r.kt)("inlineCode",{parentName:"p"},"[String]"),"."),(0,r.kt)("p",null,"A string itself is actually a sequence of characters. Hence,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest \"foo\" with ['f','o','o'] in ()\n")),(0,r.kt)("p",null,"is correct. This means that the type ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," is just an abbreviation for the sequence type ",(0,r.kt)("inlineCode",{parentName:"p"},"[Char]"),"."),(0,r.kt)("p",null,"There are several operations defined for sequences, for instance, the ",(0,r.kt)("inlineCode",{parentName:"p"},"concat")," function concatenates two sequences"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest concat [1,3,5] [7,9] with [1,3,5,7,9] in ()\n")),(0,r.kt)("p",null,"or the ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," function picks out the nth element of a sequence"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest get [3,5,8,9] 2 with 8 in ()\n")),(0,r.kt)("p",null,"It is also possible to pattern match on sequences, to either extract the ",(0,r.kt)("em",{parentName:"p"},"tail")," of a sequence, if the first part matches"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest match "foobar" with "fo" ++ rest then rest else ""\nwith "obar" in\n')),(0,r.kt)("p",null,"or the ",(0,r.kt)("em",{parentName:"p"},"head")," of a sequence if the last part matches:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest match "foobar" with first ++ "bar" then first else ""\nwith "foo" in\n')),(0,r.kt)("p",null,"It is even possible to extract the middle of a sequence, if the head and the tail matches:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest match "foobar" with "fo" ++ mid ++ "ar" then mid else ""\nwith "ob" in\n')),(0,r.kt)("p",null,"Again, matching can be combined and nested:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'utest match (1,[["a","b"],["c"]],76) with (1,b++[["c"]],76) then b else []\nwith [["a","b"]] in\n')),(0,r.kt)("h3",{id:"tensors"},"Tensors"),(0,r.kt)("p",null,"Tensors are mutable data structures and can be of up to rank 16. The index\nof an element is represented as a sequence of integers."),(0,r.kt)("p",null,"We construct tensors using ",(0,r.kt)("inlineCode",{parentName:"p"},"tensorCreateDense shape f"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"shape")," is a sequence\ndenoting the shape of the tensor and ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," is a function taking an index as an\nargument and returning the element at that index."),(0,r.kt)("p",null,"We can construct a zero-order tensor with value ",(0,r.kt)("inlineCode",{parentName:"p"},"'a'")," as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let t0 = tensorCreateDense [] (lam. 'a') in\nutest tensorRank t0 with 0 in\nutest tensorShape t0 with [] in\n")),(0,r.kt)("p",null,"We can access and mutate elements in a tensor using"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest tensorSetExn t0 [] 'b' with () in\nutest tensorGetExn t0 [] with 'b' in\n()\n")),(0,r.kt)("p",null,"The file ",(0,r.kt)("a",{parentName:"p",href:"stdlib/tensor.mc"},"tensor.mc")," contains a wide variety of useful tensor\nfunctions. We can import it into a program using the ",(0,r.kt)("inlineCode",{parentName:"p"},"include"),"\nkeyword (more on this ",(0,r.kt)("a",{parentName:"p",href:"#MLang"},"later"),"). We can construct a rank 1\ntensor (i.e. vector) as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'include "tensor.mc"\nmexpr\nlet t1 = tensorCreateDense [9] (lam i. addi (get i 0) 1) in\nutest tensorToSeqExn t1 with [1, 2, 3, 4, 5, 6, 7, 8, 9] in\n')),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"tensorToSeqExn")," is defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"tensor.mc"),"."),(0,r.kt)("p",null,"We can reshape our rank 1 tensor into a rank 2 tensor (i.e. a matrix)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let t2 = tensorReshapeExn t1 [3, 3] in\n")),(0,r.kt)("p",null,"Reshape does no copying and the data is shared between ",(0,r.kt)("inlineCode",{parentName:"p"},"t1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"t2")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"tensorSetExn t2 [0, 0] 2;\nutest tensorGetExn t1 [0] with 2 in\n")),(0,r.kt)("p",null,"We can slice the second row from ",(0,r.kt)("inlineCode",{parentName:"p"},"t2")," as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let r2 = tensorSliceExn t2 [1] in\nutest tensorToSeqExn r2 with [4, 5, 6] in\n")),(0,r.kt)("p",null,"Slicing reduces the rank of the tensor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest tensorRank r2 with 1 in\n")),(0,r.kt)("p",null,"We can slice multiple dimensions at once"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let e = tensorSliceExn t2 [1, 1] in\nutest tensorGetExn e [] with 5 in\nutest tensorRank e with 0 in\n")),(0,r.kt)("p",null,"A slice shares data with the original tensor and no copying of data is done."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"tensorMapInplace (lam. 0) r2;\nutest tensorToSeqExn t1 with [2, 2, 3, 0, 0, 0, 7, 8, 9] in\n")),(0,r.kt)("p",null,"where we use ",(0,r.kt)("inlineCode",{parentName:"p"},"tensorMapInplace")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"tensor.mc"),"."),(0,r.kt)("p",null,"We can get a subset of the rows of t2 by restricting its 0th dimension."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let s1 = tensorSubExn t2 1 2 in\nutest tensorShape s1 with [2, 3] in\nutest tensorToSeqExn (tensorReshapeExn s1 [6]) with [0, 0, 0, 7, 8, 9] in\n()\n")),(0,r.kt)("h3",{id:"references"},"References"),(0,r.kt)("p",null,"A mutable reference to an MExpr value can be created with the ",(0,r.kt)("inlineCode",{parentName:"p"},"ref")," operator. For instance"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let r = ref 3 in\n")),(0,r.kt)("p",null,"allocates a reference to a cell in memory with an initial value ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),", and binds\nthe reference to the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"deref")," operator is used for dereferencing, that is, to read the value that\na reference points to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let r = ref 3 in\nutest deref r with 3 in ()\n")),(0,r.kt)("p",null,"The value that a reference points to can be modified using the ",(0,r.kt)("inlineCode",{parentName:"p"},"modref")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let r = ref 3 in\nmodref r 4;\nutest deref r with 4 in ()\n")),(0,r.kt)("p",null,"Note that the return value of ",(0,r.kt)("inlineCode",{parentName:"p"},"modref")," is an MExpr unit value."),(0,r.kt)("p",null,"It is possible have aliases for the same memory cell by binding several\nvariables to the same reference. As an example, in the program"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'let r1 = ref "A" in\nlet r2 = r1 in\nmodref r2 "B";\nutest deref r1 with "B" in ()\n')),(0,r.kt)("p",null,"the change made to the referenced value via the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"r2")," is visible when\ndereferencing the reference via the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"r1"),"."),(0,r.kt)("h2",{id:"mlang"},"MLang"),(0,r.kt)("p",null,"MLang is a superset of MExpr, and is used to define and compose\nreusable language fragments. It also supports top-level\ndefinitions and simple file inclusion. The definitions can be\ntranslated into pure MExpr definitions, and can be run as any\nother MExpr programs."),(0,r.kt)("h3",{id:"top-level-definitions-and-includes"},"Top-Level Definitions and Includes"),(0,r.kt)("p",null,"Values, types, and data constructors can be defined top-level,\nbefore the ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr")," keyword of an MCore program. The syntax is\nidentical to that of the corresponding MExpr definitions, without\nthe trailing ",(0,r.kt)("inlineCode",{parentName:"p"},"in"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let id = lam x. x\ntype T\ncon Foo : Int -> T\n\nmexpr\n\nutest id (Foo 42) with Foo 42 in\n()\n")),(0,r.kt)("p",null,"The translation into MExpr is straightforward: the definitions are\nsimply moved into the beginning of the ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr")," program. The\nusefulness of top-level definitions becomes more apparent when\nadding included files. A file can be included using the syntax"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'include "path/to/prog.mc"\n')),(0,r.kt)("p",null,"before any top-level definitions in a\nfile. The string is a file path relative to the file that contains\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"include"),". If the environment variable ",(0,r.kt)("inlineCode",{parentName:"p"},"MCORE_STDLIB")," is\ndefined, its value is used as a fallback path to search from if\nthe file is not found relative to the original file. Files are\nincluded transitively in a depth-first fashion, and files that are\nincluded from several files are only included once. File\ninclusions that form a loop are not allowed."),(0,r.kt)("p",null,"Including a file is equivalent to inserting all the top-level\ndefinitions of that file. There are no namespaces and no\ndisambiguation; if a name defined in an included file is shadowed\nin the including file, the included definition becomes\nunavailable."),(0,r.kt)("h3",{id:"language-fragments"},"Language Fragments"),(0,r.kt)("p",null,'A language fragment contains definitions of (abstract) syntax, and\nsemantics ("interpreters") for that fragment. Any number of\nlanguage fragments can be defined before the ',(0,r.kt)("inlineCode",{parentName:"p"},"mexpr")," keyword in an\nMCore program. For example, here is a language fragment for simple\narithmetics:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'lang Arith\n  syn Expr =\n  | Num Int\n  | Add (Expr, Expr)\n\n  sem eval =\n  | Num n -> Num n\n  | Add (e1,e2) ->\n    match eval e1 with Num n1 then\n      match eval e2 with Num n2 then\n        Num (addi n1 n2)\n      else error "Not a number"\n    else error "Not a number"\nend\n')),(0,r.kt)("p",null,"The fragment defines a syntactic form with two cases called\n",(0,r.kt)("inlineCode",{parentName:"p"},"Expr"),", and an interpreter called ",(0,r.kt)("inlineCode",{parentName:"p"},"eval"),". An interpreter in MLang\nis a function that is always defined by cases over its last\nargument (here, ",(0,r.kt)("inlineCode",{parentName:"p"},"eval")," takes only a single argument). The body of\na case is a regular MExpr term, which has access to the name of\nthe value (if any) carried by the current syntactic form."),(0,r.kt)("p",null,"In the main MExpr program, a language fragment can be opened by\na ",(0,r.kt)("inlineCode",{parentName:"p"},"use")," expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mexpr\nuse Arith in\nutest eval (Add (Num 2, Num 3)) with Num 5 in\n()\n")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"use")," is translated into a series of MExpr definitions that\nmatch the syntax and semantics of the specified language fragment."),(0,r.kt)("p",null,"An important feature of language fragments is that they can be\ncomposed to form new language fragments. As an example, we might\nwant to extend our arithmetics language with booleans and ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),"\nexpressions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'lang MyBool\n  syn Expr =\n  | True()\n  | False()\n  | If (Expr, Expr, Expr)\n\n  sem eval =\n  | True() -> True()\n  | False() -> False()\n  | If(cnd,thn,els) ->\n    let cndVal = eval cnd in\n    match cndVal with True() then eval thn\n    else match cndVal with False() then eval els\n    else error "Not a boolean"\nend\n\nlang ArithBool = Arith + MyBool\n\nmexpr\nuse ArithBool in\nutest eval (Add (If (False(), Num 0, Num 5), Num 2)) with Num 7 in\n()\n')),(0,r.kt)("p",null,"The language fragment ",(0,r.kt)("inlineCode",{parentName:"p"},"ArithBool")," is indistinguishable from a\nlanguage fragment with all the syntactic and semantic cases of\n",(0,r.kt)("inlineCode",{parentName:"p"},"Arith")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"MyBool")," merged. If we wanted, we could have added new\ncases to the language composition as well, and refer to the syntax\nand semantics of the fragments being composed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'lang ArithBool = Arith + MyBool\n  syn Expr =\n  | IsZero Expr\n\n  sem eval =\n  | IsZero e ->\n    match eval e with Num n then\n      if eqi n 0 then True() else False()\n    else\n      error "Not a number"\nend\n')),(0,r.kt)("h3",{id:"known-issuesfuture-work"},"Known Issues/Future Work"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Name binding in language definitions is dynamic in where the\nlanguage is used, meaning that shadowing can change behavior in\nunexpected ways (a type system would address this to some\nextent)."),(0,r.kt)("li",{parentName:"ul"},"There are cases where it would be useful to ",(0,r.kt)("inlineCode",{parentName:"li"},"use")," language\nfragments top-level, for example when defining top-level\nfunctions that use datatypes defined in language fragments."),(0,r.kt)("li",{parentName:"ul"},"The intended rules of interpreter composition are as follows:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If a language defines a case c1 that overlaps with a case c2\nfrom a language being extended, c1 takes precedence (cf.\noverriding in inheritance)."),(0,r.kt)("li",{parentName:"ul"},"If a language extends two languages which both define the same\ncase for an interpreter, the extending language ",(0,r.kt)("em",{parentName:"li"},"must")," provide\nan overriding case for that interpreter.")))),(0,r.kt)("h2",{id:"externals-builtin"},"Externals (builtin)"),(0,r.kt)("p",null,"As part of the experimental setup of Miking, we currently support a way\nto use external libraries without interfering with the development of\nMiking that does not need these external dependencies."),(0,r.kt)("h3",{id:"python"},"Python"),(0,r.kt)("p",null,"Python intrinsics, which allow calling Python code from MCore, are offered as an optional feature for the ",(0,r.kt)("inlineCode",{parentName:"p"},"boot")," bootstrap interpreter.\nTo build the project with Python integration you need to have ",(0,r.kt)("a",{parentName:"p",href:"https://www.python.org"},"Python 3")," installed on your system.\nYou will also need to install any Python libraries you want to use (for example using pip)."),(0,r.kt)("p",null,"In addition, you need the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/thierry-martinez/pyml"},"pyml")," OCaml Python bindings, available via ",(0,r.kt)("inlineCode",{parentName:"p"},"opam"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam install pyml\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"boot")," will automatically be compiled with Python support when the ",(0,r.kt)("inlineCode",{parentName:"p"},"pyml")," package is installed."),(0,r.kt)("p",null,"NOTE: Currently, there seems to be a problem with the current OPAM bindings with the multicore switch. If the above command fails, try to run the following and then install ",(0,r.kt)("inlineCode",{parentName:"p"},"pyml")," again:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam pin stdcompat 15\n")),(0,r.kt)("p",null,"To run the Python-specific test suite:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make test-boot-py\n")),(0,r.kt)("p",null,"To install for the current user, run ",(0,r.kt)("inlineCode",{parentName:"p"},"make install")," as usual."),(0,r.kt)("h4",{id:"usage"},"Usage"),(0,r.kt)("p",null,"The following example shows how to use the intrinsics to sort a sequence using\nPython's builtin ",(0,r.kt)("inlineCode",{parentName:"p"},"sorted")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'let builtins = pyimport "builtins"\n\nlet x = [5.,4.5,4.,1.,1.5]\nlet y = pycall builtins "sorted" (x,)\nlet x_sorted = pyconvert y\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pycall")," is the main piece of the Python intrinsics: in the example above,\nit is used to call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"sorted")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"builtins")," module, imported\nwith the ",(0,r.kt)("inlineCode",{parentName:"p"},"pyimport")," intrinsic. As the example shows, arguments are\npassed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"pycall")," intrinsic using tuples (remember that ",(0,r.kt)("inlineCode",{parentName:"p"},"(x,)")," is a\nsingleton tuple containing ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"). The result of a ",(0,r.kt)("inlineCode",{parentName:"p"},"pycall")," (",(0,r.kt)("inlineCode",{parentName:"p"},"y")," in the example\nabove) is a Python value, which can either be passed to other Python functions,\nor converted back to an MCore sequence using the ",(0,r.kt)("inlineCode",{parentName:"p"},"pyconvert")," builtin."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pycall")," can also be used to call methods of objects by passing an object\ninstead of a module as the first argument. For example, the following code\nwill invoke the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," method of a list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'let builtins = pyimport "builtins"\n\nlet pylist = pycall builtins "list" ([1,1,2],)\nlet ones = pyconvert (pycall pylist "count" (1,))\n')),(0,r.kt)("p",null,"In the examples above, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"builtins")," module to access Python's builtins.\nOther modules can also be imported as long as they are available in the Python\npath: for instance, it is perfectly possible to import ",(0,r.kt)("inlineCode",{parentName:"p"},"numpy")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"matplotlib"),",\nassuming that they are installed."),(0,r.kt)("p",null,"The following example shows how a numpy ",(0,r.kt)("inlineCode",{parentName:"p"},"nparray")," can be created and converted\nto an MCore sequence. The key here is to use numpy's ",(0,r.kt)("inlineCode",{parentName:"p"},"tolist")," method first,\nsince conversion directly from ",(0,r.kt)("inlineCode",{parentName:"p"},"nparray")," is not supported."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'let rnd = pyimport "numpy.random"\n\nlet nparray = pycall rnd "normal" (0., 0.1, 10)\nlet mc_seq = pyconvert (pycall nparray "tolist" ())\n')),(0,r.kt)("p",null,"In the next example, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"matplotlib")," to produce a plot; this works in\nexactly the same way as in a regular Python program."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'let plt = pyimport "matplotlib.pyplot"\nlet np = pyimport "numpy"\n\nlet x = pycall np "arange" (0, 4, 0.1)\nlet y = pycall np "cos" (x,)\nlet _ = pycall plt "plot" (x, y)\nlet _ = pycall plt "show" ()\n')),(0,r.kt)("h4",{id:"conversion-between-mcore-and-python"},"Conversion between MCore and Python"),(0,r.kt)("p",null,"When calling a Python function using the ",(0,r.kt)("inlineCode",{parentName:"p"},"pycall")," builtin, the arguments will be\nautomatically converted from MCore values to Python values. Similarly, the\nopposite conversion is performed when using ",(0,r.kt)("inlineCode",{parentName:"p"},"pyconvert")," on the result of a\n",(0,r.kt)("inlineCode",{parentName:"p"},"pycall"),". This section explains the details of these conversions."),(0,r.kt)("h5",{id:"from-mcore-to-python"},"From MCore to Python"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"MCore type"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Python type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Bool"),(0,r.kt)("td",{parentName:"tr",align:"left"},"bool")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Int"),(0,r.kt)("td",{parentName:"tr",align:"left"},"int")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Char"),(0,r.kt)("td",{parentName:"tr",align:"left"},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"float")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"[Char]"," (String)"),(0,r.kt)("td",{parentName:"tr",align:"left"},"str")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"[a]"),(0,r.kt)("td",{parentName:"tr",align:"left"},"List")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"()"),(0,r.kt)("td",{parentName:"tr",align:"left"},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Record"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Dict")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Tuple (Record)"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Tuple")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"other"),(0,r.kt)("td",{parentName:"tr",align:"left"},"N/A")))),(0,r.kt)("h5",{id:"from-python-to-mcore"},"From Python to MCore"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Python type"),(0,r.kt)("th",{parentName:"tr",align:"left"},"MCore type"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Bool")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"int"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Int")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"long"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Int")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"float"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Float")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"str"),(0,r.kt)("td",{parentName:"tr",align:"left"},"[Char]"," (String)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"List"),(0,r.kt)("td",{parentName:"tr",align:"left"},"[a]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"None"),(0,r.kt)("td",{parentName:"tr",align:"left"},"()")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Dict"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Record")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Tuple"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Tuple (Record)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"other"),(0,r.kt)("td",{parentName:"tr",align:"left"},"N/A")))),(0,r.kt)("h2",{id:"externals"},"Externals"),(0,r.kt)("p",null,"Externals allows you to interact with code in the compilation target language\nfrom miking. Currently, externals are only available in compiled code and are\nin an early stage of development. The example below only covers the case where\nOCaml is the target language."),(0,r.kt)("p",null,"You can find an example of externals definitions in\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/ext/math-ext.mc"},"stdlib/ext/math-ext.mc")," and\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/ext/math-ext.ext-ocaml.mc"},"stdlib/ext/math-ext.ext-ocaml.mc"),"."),(0,r.kt)("p",null,"For the sake of this example, lets say we want to define the exponential\nfunction and that miking targeting OCaml should use ",(0,r.kt)("inlineCode",{parentName:"p"},"Float.exp")," from OCaml's\nstandard library for its implementation."),(0,r.kt)("p",null,"We first define the external in a file under ",(0,r.kt)("a",{parentName:"p",href:"stdlib/ext"},"stdlib/ext"),", let's\nsay ",(0,r.kt)("a",{parentName:"p",href:"stdlib/ext/math-ext.mc"},"stdlib/ext/math-ext.mc"),", as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"external externalExp : Float -> Float\n")),(0,r.kt)("p",null,"which makes an external value ",(0,r.kt)("inlineCode",{parentName:"p"},"externalExp")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Float -> Float")," available\nat the top-level. The corresponding MCore syntax is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"external ident : Type in expr\n")),(0,r.kt)("p",null,"If the external has side-effects it should be annotated with a ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," after the\nidentifier, e.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"external print ! : String -> ()\n")),(0,r.kt)("p",null,"Each external identifier can only be defined once and externals cannot be\npartially applied."),(0,r.kt)("p",null,"As a temporary solution, the next step is to supply a list of implementation for\nour external in the language we target for compilation (in this case OCaml). We\ndo this by creating a file\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/ext/math-ext.ext-ocaml.mc"},"stdlib/ext/math-ext.ext-ocaml.mc"),"\nand in it we define a map from external\nidentifiers to a list of implementations as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'include "map.mc"\ninclude "ocaml/ast.mc"\n\nlet mathExtMap =\n  use OCamlTypeAst in\n  mapFromSeq cmpString\n  [\n    ("externalExp", [\n      { \n        expr = "Float.exp", \n        ty = tyarrow_ tyfloat_ tyfloat_ , \n        libraries = [], \n        cLibraries = [] \n      }\n    ])\n  ]\n')),(0,r.kt)("p",null,"This map associates the ",(0,r.kt)("inlineCode",{parentName:"p"},"externalExp")," external to a list of expressions in the\ntarget language, which here only has one element, namely the function\n",(0,r.kt)("inlineCode",{parentName:"p"},"Float.exp")," from OCaml's standard library. The field ",(0,r.kt)("inlineCode",{parentName:"p"},"ty")," encode the OCaml type\nof this value (see ",(0,r.kt)("a",{parentName:"p",href:"stdlib/ocaml/ast.mc"},"stdlib/ocaml/ast.mc"),"), which is needed\nto convert values between miking and OCaml. In the case where you have multiple\nimplementations, the compiler will try to pick the implementation which gives\nthe least amount of overhead when converting to and from OCaml values. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"libraries")," field list OCaml libraries that are needed to call this function,\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"cLibraries")," lists c libraries that are needed during linking. In this case\nnone are needed since it is part of the standard library. If let's say we wanted\nto use ",(0,r.kt)("inlineCode",{parentName:"p"},"Float.exp")," from a library ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),", then we should instead have the field\n",(0,r.kt)("inlineCode",{parentName:"p"},'libraries = ["foo"]'),". Finally, we need to add ",(0,r.kt)("inlineCode",{parentName:"p"},"mathExtMap")," to\n",(0,r.kt)("inlineCode",{parentName:"p"},"globalExternalImplsMap")," in\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/ocaml/external-includes.mc"},"stdlib/ocaml/external-includes.mc"),"."),(0,r.kt)("h3",{id:"conversion-between-values"},"Conversion between values"),(0,r.kt)("p",null,"Conversion between Miking values and OCaml values is defined in\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/ocaml/external.mc"},"stdlib/ocaml/external.mc"),". Since externals are in an\nearly stage of development these conversions are not complete and subject to\nchange. "),(0,r.kt)("p",null,"The following Basic types are converted without any computational overhead:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"Miking type")),(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"OCaml type")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Int")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"int"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Float")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"float"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Bool")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"The overhead of converting sequences to OCaml data-structures is proportional to\nthe length of the sequence times the conversion cost for the type of the\nelements. Strings in Miking is a special case of sequences."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"Miking type")),(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"OCaml type")),(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"Comment")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"[A]")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"'a list")),(0,r.kt)("td",{parentName:"tr",align:"left"})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"[A]")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"'a array")),(0,r.kt)("td",{parentName:"tr",align:"left"},"A copy is made, mutating the OCaml array does not mutate the sequence.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"[Char]")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"String")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:"left"},"The Miking string is converted to, and the OCaml string is assumed to be, encoded in UTF-8.")))),(0,r.kt)("p",null,"Tensors are passed by reference to OCaml, i.e. mutating the corresponding\ndata-structure in OCaml will mutate the tensor. As a temporary solution the\nconversion depends on the underlying implementation of the tensor, which is\ncontrolled by the tensor create functions ",(0,r.kt)("inlineCode",{parentName:"p"},"tensorCreateDense"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"tensorCreateCArrayInt"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"tensorCreateCArrayFloat"),". The main purpose of the\nlatter two is to allow data-sharing with C libraries via OCaml bindings."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"Miking type")),(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"OCaml type")),(0,r.kt)("th",{parentName:"tr",align:"left"},(0,r.kt)("strong",{parentName:"th"},"Comment")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Tensor[Int]")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Bigarray.((int, int_elt, c_layout) genarray.t)")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Must use ",(0,r.kt)("inlineCode",{parentName:"td"},"tensorCreateCArrayInt"),", otherwise a runtime error occurs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Tensor[Float]")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Bigarray.((float, float64_elt, c_layout) genarray.t)")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Must use ",(0,r.kt)("inlineCode",{parentName:"td"},"tensorCreateCArrayFloat"),", otherwise a runtime error occurs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Tensor[Int]")," of rank 1"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Bigarray.((int, int_elt, c_layout) Array1.t)")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Must use ",(0,r.kt)("inlineCode",{parentName:"td"},"tensorCreateCArrayInt"),", otherwise a runtime error occurs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Tensor[Float]")," of rank 1"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Bigarray.((float, float64_elt, c_layout) Array1.t)")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Must use ",(0,r.kt)("inlineCode",{parentName:"td"},"tensorCreateCArrayFloat"),", otherwise a runtime error occurs.")))),(0,r.kt)("p",null,"Tuples are converted without overhead if the conversion of their elements are\nwithout overhead. The same is true for arrow types. The fields in Miking records\nare un-ordered while they are ordered in OCaml so there is some overhead\ninvolved when converting records as each field of the Miking records needs to be\nprojected to form an new OCaml records, and vice versa. The fields of the Miking\nrecord are associated with the fields of the OCaml record by an explicit mapping\ndefined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"*.ext-ocaml.mc")," file."),(0,r.kt)("p",null,"If the Miking type is abstract, i.e. we define it as "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"type MyType\n")),(0,r.kt)("p",null,"then no conversion is performed to and from this type."),(0,r.kt)("p",null,"Please consult ",(0,r.kt)("a",{parentName:"p",href:"stdlib/ext/ext-test.mc"},"stdlib/ext/ext-test.mc")," and\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/ext/ext-test.ext-ocaml.mc"},"stdlib/ext/ext-test.ext-ocaml.mc"),", for more\nexamples."),(0,r.kt)("h3",{id:"sundials"},"Sundials"),(0,r.kt)("p",null,"A more involved example on the use of externals is an interface to the\n",(0,r.kt)("a",{parentName:"p",href:"https://computing.llnl.gov/projects/sundials"},"Sundials")," numerical DAE solver.\nYou find the implementation in\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/sundials/sundials.mc"},"stdlib/sundials/sundials.mc")," and\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/sundials/sundials.ext-ocaml.mc"},"stdlib/sundials/sundials.ext-ocaml.mc"),".\nNote that these externals depends on the library ",(0,r.kt)("inlineCode",{parentName:"p"},"sundialsml"),"."),(0,r.kt)("p",null,"Installing this library involves first installing the Sundials C library. On\n",(0,r.kt)("inlineCode",{parentName:"p"},"ubuntu 20.04")," you can do this by:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sudo apt-get install libsundials-dev\n")),(0,r.kt)("p",null,"On ",(0,r.kt)("inlineCode",{parentName:"p"},"macOS"),", using Homebrew, you instead do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"brew install sundials\n")),(0,r.kt)("p",null,"Then install the ocaml bindings\n",(0,r.kt)("a",{parentName:"p",href:"https://inria-parkas.github.io/sundialsml/"},"SundialsML")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"opam")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam install sundialsml\n")),(0,r.kt)("p",null,"Currently, this library cannot be installed on the multi-core switch but you\ninstead have to use another opam switch, e.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam switch 4.12.0\n")),(0,r.kt)("p",null,"After this you have to rebuild the compiler, e.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make clean\nmake\n")),(0,r.kt)("p",null,"To run the sundials-specific test suite, use the command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make test-sundials\n")),(0,r.kt)("p",null,"To install for the current user, run ",(0,r.kt)("inlineCode",{parentName:"p"},"make install")," as usual."),(0,r.kt)("h3",{id:"ipopt"},"Ipopt"),(0,r.kt)("p",null,"Another example use of externals is an interface to the constrained Non-Linear\nProgram solver ",(0,r.kt)("a",{parentName:"p",href:"https://coin-or.github.io/Ipopt/"},"Ipopt"),". This interface is\ndefined in ",(0,r.kt)("a",{parentName:"p",href:"stdlib/ipopt/ipopt.mc"},"stdlib/ipopt/ipopt.mc")," and\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/ipopt/ipopt.ext-ocaml.mc"},"stdlib/ipopt/ipopt.ext-ocaml.mc"),". This library\ndepends on both the OCaml library ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/br4sco/ipoptml"},"ipoptml"),"\nand the ipopt c library."),(0,r.kt)("p",null,"To use this library you need to do the following:"),(0,r.kt)("p",null,"Install the ipopt c library, which you can do on ubuntu 20.04 with"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sudo apt-get install coinor-libipopt-dev\n")),(0,r.kt)("p",null,"Install dependencies for ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/br4sco/ipoptml"},"ipoptml"),","),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam install ctypes ctypes-foreign\n")),(0,r.kt)("p",null,"Clone the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/br4sco/ipoptml"},"ipoptml")," repo and in its root run"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dune build\ndune install\n")),(0,r.kt)("p",null,"You can then test the solver in Miking with"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"make test-ipopt\n")),(0,r.kt)("h3",{id:"external-dependent-utests-pruning"},"External Dependent Utests Pruning"),(0,r.kt)("p",null,"As part of the parsing (see ",(0,r.kt)("inlineCode",{parentName:"p"},"prune_external_utests")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"parserutils.ml")," for\ndetails) utests that depend on externals are marked and removed. This done in\nthe following steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Dead code removal is performed to remove dead code, including any dead code\ninside utests that might reference externals. This is done to reduce the\nnumber of false positivities."),(0,r.kt)("li",{parentName:"ol"},"Utests that references externals are marked and removed."),(0,r.kt)("li",{parentName:"ol"},"Dead code removal is run again to remove any dead code that result from the\nremoval of utests in step 2.")),(0,r.kt)("p",null,"Additionally, if ",(0,r.kt)("inlineCode",{parentName:"p"},"boot")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"mi")," is run without the ",(0,r.kt)("inlineCode",{parentName:"p"},"--test")," flag, all utests are\nremoved prior to dead code removal as all utests can then be considered dead\ncode. This both allows the dead code removal to remove more dead code and\nsimplifies the pruning of utests implementation. If any utest pruning is\nperformed, a warning summarizing pruned utests is printed to ",(0,r.kt)("em",{parentName:"p"},"stdout"),"."),(0,r.kt)("p",null,"The pruning of utests can be disabled with the ",(0,r.kt)("inlineCode",{parentName:"p"},"--disable-prune-utests")," flag and\ndebugged with ",(0,r.kt)("inlineCode",{parentName:"p"},"--debug-prune-utests")," (only in boot)."),(0,r.kt)("p",null,"Moreover, pruning of utests can be disabled for a selection of externals, which\nallows for a more granular approach to the testing of external dependent code\n(see below)."),(0,r.kt)("h4",{id:"selective-pruning"},"Selective pruning"),(0,r.kt)("p",null,"During compilation, the available OCaml packages on the\ncurrent system is queried and externals depending on these packages are excluded\nfrom utests pruning. In other words, utests that depend on externals that can be\ncompiled on the system are kept, while all others are removed. The listing of\nOCaml packages is based around ",(0,r.kt)("inlineCode",{parentName:"p"},"dune installed-libraries")," (see\n",(0,r.kt)("inlineCode",{parentName:"p"},"externalListOcamlPackages")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"externalGetSupportedExternalImpls")," in\n",(0,r.kt)("inlineCode",{parentName:"p"},"external-includes.mc")," so this functionality should not require any additional\ndependencies. For boot and the interpreter, ",(0,r.kt)("em",{parentName:"p"},"all")," external dependent utests are\nremoved as these currently do not support externals at all."),(0,r.kt)("h4",{id:"test-organization"},"Test organization"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"make test-all")," runs all tests, disabling utest pruning for compiled files\n(i.e. if dependencies are not met, you get an error). The recepie ",(0,r.kt)("inlineCode",{parentName:"p"},"make\ntest-all-prune-utests")," runs all tests but prunes non-supported utests which is\nhandy if your system only meet the dependencies of a subset of the\nexternals. Interpreted files are always pruned of external dependent\nutests. Please consult the makefiles for more details."),(0,r.kt)("h4",{id:"authoring-new-external-libraries"},"Authoring new external libraries"),(0,r.kt)("p",null,"To maintain the flexibility of the test organization, future external libraries\nmust ensure that externals, or external dependent identifiers are only fully\napplied inside utests. To verify that this is the case you can just run ",(0,r.kt)("inlineCode",{parentName:"p"},"boot\neval --test <file.mc>")," and verify that you get a non-zero exit code on the\nlibrary that you are currently working on."),(0,r.kt)("h3",{id:"parallel-programming"},"Parallel Programming"),(0,r.kt)("p",null,"Miking offers a set of externals for shared-memory parallelism using\natomic operations and threads running on multiple cores."),(0,r.kt)("p",null,"The parallel programming primitives consist of atomic references and functions\nfor creating and synchronizing threads. In addition to the examples below, more\ndocumentation can be found in the standard library at\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/multicore/"},"stdlib/multicore"),"."),(0,r.kt)("h4",{id:"atomic-references"},"Atomic References"),(0,r.kt)("p",null,"Atomic references are similar to ordinary references, except that operations\nperformed on them are ",(0,r.kt)("em",{parentName:"p"},"atomic"),", which means that no other execution thread can\ninterfere with the result. In other words, they are safe to use in\nmulti-threaded execution. Atomic references are provided in\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/multicore/atomic.mc"},"multicore/atomic.mc"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"atomicMake")," creates a new atomic reference and gives it an initial value. The\nvalue of the atomic reference can be read by ",(0,r.kt)("inlineCode",{parentName:"p"},"atomicGet"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'include "multicore/atomic.mc"\nmexpr\nlet a = atomicMake 0 in\nutest atomicGet a with 0 in\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"atomicCAS a oldVal newVal")," performs an atomic compare-and-set, that is, it only\nupdates the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"newVal")," if the current value is identical to\n",(0,r.kt)("inlineCode",{parentName:"p"},"oldVal"),", and then returns a Boolean representing if the update was successful\nor not:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest atomicCAS a 0 1 with true in\nutest atomicCAS a 42 3 with false in\nutest atomicGet a with 1 in\n")),(0,r.kt)("p",null,"The compare-and-set operation is currently supported for integer atomic\nreferences only."),(0,r.kt)("p",null,"To unconditionally set the value of an atomic reference, we can use\n",(0,r.kt)("inlineCode",{parentName:"p"},"atomicExchange"),", which also returns the old value of the reference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest atomicExchange a 2 with 1 in\n")),(0,r.kt)("p",null,"Finally, for integer references, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"atomicFetchAndAdd")," to increase or\ndecrease the value of the reference. The function returns the old value of the\nreference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"utest atomicFetchAndAdd a 1 with 2 in\n-- Current value is now 3\nutest atomicFetchAndAdd a (subi 0 45) with 3 in\n-- Current value is now -42\n")),(0,r.kt)("h4",{id:"multi-threaded-execution"},"Multi-Threaded Execution"),(0,r.kt)("p",null,"Functions for handling threads are provided in\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/multicore/threads.mc"},"multicore/threads.mc"),".\nThe following example program spawns 10 threads that compete for printing their\nIDs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'include "string.mc"\ninclude "multicore/thread.mc"\nmexpr\nlet place = atomicMake 1 in\nlet threads = create 10 (lam. threadSpawn (lam.\n  print (join\n    [int2string (atomicFetchAndAdd place 1)\n    , ": thread ID "\n    , int2string (threadSelf ())\n    , "\\n"\n    ]))\n) in\nmap threadJoin threads\n')),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"threadSpawn")," takes a function of type ",(0,r.kt)("inlineCode",{parentName:"p"},"() -> a")," as argument\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"threadSelf")," returns the ID of the current thread. Note that\n",(0,r.kt)("inlineCode",{parentName:"p"},"threadJoin")," must be called once for each call to ",(0,r.kt)("inlineCode",{parentName:"p"},"threadSpawn"),". The\noutput of the above program might be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1: thread ID 1\n2: thread ID 2\n3: thread ID 129\n4: thread ID 130\n5: thread ID 3\n6: thread ID 257\n7: thread ID 258\n8: thread ID 131\n9: thread ID 385\n10: thread ID 386\n")),(0,r.kt)("p",null,"However, the values and order of the thread IDs might be different over\ndifferent runs."),(0,r.kt)("h4",{id:"synchronization"},"Synchronization"),(0,r.kt)("p",null,"Externals for thread synchronization in the form of mutual exclusion locks and\ncondition variables are defined in\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/multicore/mutex.mc"},"multicore/mutex.mc")," and\n",(0,r.kt)("a",{parentName:"p",href:"stdlib/multicore/cond.mc"},"multicore/cond.mc"),", respectively."),(0,r.kt)("h3",{id:"probability-distributions"},"Probability distributions"),(0,r.kt)("p",null,"Externals for probability distributions are defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"stdlib/ext/dist-ext.mc"),". To use these, you must install the ",(0,r.kt)("inlineCode",{parentName:"p"},"opam")," package ",(0,r.kt)("inlineCode",{parentName:"p"},"owl")," (i.e., ",(0,r.kt)("inlineCode",{parentName:"p"},"opam install owl"),")"),(0,r.kt)("h2",{id:"profiling"},"Profiling"),(0,r.kt)("p",null,"Profiling of an MExpr program can be enabled using the ",(0,r.kt)("inlineCode",{parentName:"p"},"--debug-profile")," flag\nwhen compiling or evaluating a program. While this flag also exists in the boot\ninterpreter, it produces a subset of profiling information than the profiling\napproach used in ",(0,r.kt)("inlineCode",{parentName:"p"},"mi")," (which is what is detailed below)."),(0,r.kt)("h3",{id:"profiling-output"},"Profiling output"),(0,r.kt)("p",null,"The profiling results are stored in a file ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr.prof")," in the current working\ndirectory. If such a file already exists, it will be overwritten. This file\nis created when:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The execution of a compiled program, which had been compiled with the\n",(0,r.kt)("inlineCode",{parentName:"li"},"--debug-profile")," flag enabled, terminates."),(0,r.kt)("li",{parentName:"ul"},"The interpreter of a program terminates, and the ",(0,r.kt)("inlineCode",{parentName:"li"},"--debug-profile")," flag was\nenabled.")),(0,r.kt)("p",null,"Note that no profiling information is generated during the compilation step,\nbecause the profiling code is instrumented into the produced binary."),(0,r.kt)("h4",{id:"output-format"},"Output format"),(0,r.kt)("p",null,"The profiling output contains one line per top-level function in the program,\nexcluding those that are never used during an execution of the program. The\norder of the lines is based on the order in which the functions have been\ndefined in the program. Functions defined in included files will also be listed\nin the profiling output, given that they are used."),(0,r.kt)("p",null,"Each line of output consists of five space-separated columns:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A string, denoting the name of the file and the position within the file,\nencoded as ",(0,r.kt)("inlineCode",{parentName:"li"},"[<start row>:<start col>-<end row>:<end col>]"),", where the function\nis defined."),(0,r.kt)("li",{parentName:"ol"},"A string, denoting the name of the function."),(0,r.kt)("li",{parentName:"ol"},"An integer, denoting the number of calls made to the function. The counter\nincludes self-recursive calls."),(0,r.kt)("li",{parentName:"ol"},"A floating-point number, denoting the exclusive time spent in the function.\nThis is the time spent in a call, except the time spent in calls to other\ntop-level functions (including itself)."),(0,r.kt)("li",{parentName:"ol"},"A floating-point number, denoting the inclusive time spent in the function.\nThis is the total time spent in all calls to the function, including that\nspent in calls to other top-level functions. As this includes self-recursive\ncalls, this value may be greater than the total runtime.")),(0,r.kt)("h4",{id:"postprocessing"},"Postprocessing"),(0,r.kt)("p",null,"The output format was chosen to be easily sorted using external tools, such as\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"sort")," command in Unix. Below we provide two examples of how the output can\nbe sorted. These assume that the profiling output is stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"mexpr.prof")," and\nthat the sorted profiling output should be stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"sorted.prof"),"."),(0,r.kt)("p",null,"To sort the functions by the number of times they were called, with the most\nfrequently called function at the top:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cat mexpr.prof | sort -k3 -r -n > sorted.prof\n")),(0,r.kt)("p",null,"To sort the functions by the exclusive time spent within them, placing the\nfunction with the highest exclusive time at the top:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cat mexpr.prof | sort -k4 -r -g > sorted.prof\n")),(0,r.kt)("h3",{id:"notes"},"Notes"),(0,r.kt)("p",null,"This instrumentation is currently only performed on functions defined on the\ntop-level in a program. The runtime of local functions and intrinsic functions\nis instead added to the top-level function in which they are used. In addition,\npartially applied functions are not profiled."),(0,r.kt)("p",null,"Importantly, this profiling works by instrumenting the code with extra calls.\nThe runtime overhead when enabling this flag is significant, especially when\nusing the evaluator."),(0,r.kt)("h2",{id:"acceleration"},"Acceleration"),(0,r.kt)("p",null,"When compiling using ",(0,r.kt)("inlineCode",{parentName:"p"},"mi compile"),", expression acceleration can be enabled via\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"--accelerate")," flag. When enabled, parts of the program is compiled in an\naccelerated mode, as controlled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"accelerate")," expression. The main part\nof the program is compiled to the default backend (OCaml), while expressions\nused in ",(0,r.kt)("inlineCode",{parentName:"p"},"accelerate")," expressions are compiled to an accelerate backend, chosen\nautomatically by the compiler."),(0,r.kt)("h3",{id:"accelerate-backends"},"Accelerate backends"),(0,r.kt)("p",null,"The current compiler has support for two different accelerate backends, both of\nwhich require a GPU to compile the code. The Futhark backend is used when at\nleast one of the ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"map2"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"reduce")," parallel keywords are used within\nan accelerated expression. To make use of this backend, ",(0,r.kt)("inlineCode",{parentName:"p"},"futhark")," and its\ndependencies must be installed\n(see ",(0,r.kt)("a",{parentName:"p",href:"https://futhark.readthedocs.io/en/stable/installation.html"},"installation instructions"),").\nIf the ",(0,r.kt)("inlineCode",{parentName:"p"},"loop")," parallel keyword is used in an accelerated expression, the CUDA\nbackend is used. At least one of these keywords must be used in the accelerated\ncode, or the compiler will complain as the accelerated code would execute\nsequentially."),(0,r.kt)("p",null,"Both backends currently require an installation of CUDA. In addition, the CUDA\nbackend requires an Nvidia GPU with support for unified memory (Kepler\narchitecture or later)."),(0,r.kt)("h3",{id:"usage-1"},"Usage"),(0,r.kt)("p",null,"When enabling acceleration via ",(0,r.kt)("inlineCode",{parentName:"p"},"mi compile --accelerate"),", the parallel keywords\nmust be used for parallel execution. Any code used in an ",(0,r.kt)("inlineCode",{parentName:"p"},"accelerate")," is passed\nto the automatically chosen accelerate backend. Within such code, certain\nparallel keywords must be used to execute on the GPU. The parallel keywords\nsupported in the Futhark backend are ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"map2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"reduce"),". For the CUDA\nbackend, this is ",(0,r.kt)("inlineCode",{parentName:"p"},"loop"),". Note that there are limitations on what kinds of\nexpressions can be accelerated. The compiler will report errors in such cases."),(0,r.kt)("p",null,"When compiling without enabling acceleration, the ",(0,r.kt)("inlineCode",{parentName:"p"},"accelerate")," expressions in\nthe program are ignored, and all parallel constructs are executed sequentially."),(0,r.kt)("h4",{id:"recommended-workflow"},"Recommended workflow"),(0,r.kt)("p",null,"The recommended workflow when using acceleration is as follows. First, develop\nthe program in ",(0,r.kt)("em",{parentName:"p"},"debug mode"),", using the ",(0,r.kt)("inlineCode",{parentName:"p"},"--debug-accelerate")," flag. This enables\nstatic well-formedness checks plus additional dynamic checks for the\naccelerated code, plus provides improved error messages on errors for built-in\nfunctions. This mode produces significantly better error messages than when\ncompiling without any flags, but has an impact on the runtime performance."),(0,r.kt)("p",null,"Once the program in debug mode works as expected, the program is compiled in\n",(0,r.kt)("em",{parentName:"p"},"accelerate mode"),". In this mode, the ",(0,r.kt)("inlineCode",{parentName:"p"},"--accelerate")," flag is set to enable\nacceleration. The accelerated binary produced when compiling in accelerate mode\ndoes not fail given that the debug binary did not fail."),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"--debug-accelerate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"--accelerate")," flags are mutually\nexclusive. That is, you cannot use both configurations simultaneously."),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("p",null,"Assume the program below is saved in a file ",(0,r.kt)("inlineCode",{parentName:"p"},"example.mc"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mexpr\nlet f = lam x. addi (muli x 2) 1 in\nlet s = [1,2,3] in\naccelerate (map f s) -- result = [3,5,7]\n")),(0,r.kt)("p",null,"If we compile the program as ",(0,r.kt)("inlineCode",{parentName:"p"},"mi compile example.mc"),", acceleration is disabled,\nso the ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," is executed sequentially. However, if the program is compiled\nusing ",(0,r.kt)("inlineCode",{parentName:"p"},"mi compile --accelerate example.mc"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," function ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," is applied\nto the elements of ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," in parallel, on the GPU. In this case, as we make use of\n",(0,r.kt)("inlineCode",{parentName:"p"},"map"),", it will execute using the Futhark backend."),(0,r.kt)("p",null,"See the ",(0,r.kt)("a",{parentName:"p",href:"test/examples/accelerate"},"accelerate examples")," directory for more\nexamples."),(0,r.kt)("h3",{id:"sequence-sizes"},"Sequence sizes"),(0,r.kt)("p",null,"A significant difference between MExpr and Futhark is that the latter includes\nthe size of a sequence as part of its type. This means that, for example, when\na function returns a two-dimensional sequence, the inner sequences must all\nhave the same size (otherwise they would have different types). As this is not\nrequired by MExpr, there are situations where one may need to provide\nadditional information in MExpr to help the Futhark compiler."),(0,r.kt)("p",null,"Such information is provided through ",(0,r.kt)("inlineCode",{parentName:"p"},"utest")," expressions of specific shapes.\nThe idea is that, when the program is compiled in debug mode, the ",(0,r.kt)("inlineCode",{parentName:"p"},"utest"),"\nexpressions are checked at runtime. If such a ",(0,r.kt)("inlineCode",{parentName:"p"},"utest")," fails at runtime when\ncompiled in debug mode, it would also fail in the accelerated code, but likely\nwith a less understandable error message."),(0,r.kt)("p",null,"In the future, the accelerate compiler will statically check that the necessary\nsize constraints have been added. For now, failing to provide sufficient\ninformation results in a Futhark compilation error."),(0,r.kt)("h4",{id:"size-coercions"},"Size coercions"),(0,r.kt)("p",null,"Consider the following example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mexpr\nlet g : [Int] -> [Int] = lam s. snoc s 5 in\nlet f : [[Int]] -> [[Int]] = lam s. map g s in\nlet s : [[Int]] = [[1,2],[3,4]] in\nlet s : [[Int]] = accelerate (f s) in\ns\n")),(0,r.kt)("p",null,"In the function ",(0,r.kt)("inlineCode",{parentName:"p"},"g"),", the size of the array is increased because ",(0,r.kt)("inlineCode",{parentName:"p"},"snoc")," appends\nan integer element to the end of the given sequence. In this case, the size of\nthe output sequence is not the same as the size of the input sequence. Because\nof this, the Futhark compiler cannot show that all inner sequences produced in\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," function will have the same size."),(0,r.kt)("p",null,"We can show this by adding a ",(0,r.kt)("inlineCode",{parentName:"p"},"utest")," of the shape ",(0,r.kt)("inlineCode",{parentName:"p"},"utest length s with n in e"),"\nwithin the inner function. Here ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," is an expression referring to a sequence\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is a variable from an outer scope (or a parameter), such that the\ncompiler knows it is the same for every inner sequence. We rewrite ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let f : [[Int]] -> [[Int]] = lam s.\n  -- 'n' is defined outside the map function so that the compiler knows this\n  -- size will be the same for every inner sequence.\n  let n = addi (length s) 1 in\n  map\n    (lam inner : [Int].\n      let inner : [Int] = g inner in\n      utest length inner with n in\n      inner)\n    s\nin\n")),(0,r.kt)("h4",{id:"size-equality"},"Size equality"),(0,r.kt)("p",null,"Consider the following implementation of the transpose operation on a square\nmatrix:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let transposeSq : [[Int]] -> [[Int]] = lam m.\n  let n = length m in\n  create n (lam i : Int.\n    let inner : [Int] = create n (lam j : Int. get (get m j) i) in\n    inner)\nin\n...\n")),(0,r.kt)("p",null,"The implementation accepts a matrix of any form, even though this would only\nwork for a square matrix. By inserting a ",(0,r.kt)("inlineCode",{parentName:"p"},"utest")," of the form\n",(0,r.kt)("inlineCode",{parentName:"p"},"utest length m with length (head m) in e")," (we assume inner dimensions are\nnon-empty), we can express an equality constraint between the first two\ndimensions of the matrix ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),", which may be needed when this function is used in\nother places."),(0,r.kt)("h3",{id:"limitations"},"Limitations"),(0,r.kt)("p",null,"There are limitations on what kinds of expressions can be accelerated. The\nexact limitations depend on which accelerate backend is used. They apply to\nthe accelerated expressions and any code these make use of. Many limitations\nare checked statically when compiling with ",(0,r.kt)("inlineCode",{parentName:"p"},"--accelerate"),". When using\n",(0,r.kt)("inlineCode",{parentName:"p"},"--debug-accelerate"),", a few limitations are also checked dynamically."),(0,r.kt)("p",null,"In addition, we assume that the parallel operations performed in a ",(0,r.kt)("inlineCode",{parentName:"p"},"reduce")," or\n",(0,r.kt)("inlineCode",{parentName:"p"},"loop")," yield the same result regardless of execution order. If this requirement\nis not met, the results may vary between executions."),(0,r.kt)("h2",{id:"auto-tuning"},"Auto Tuning"),(0,r.kt)("p",null,"An MExpr program can contain decision variables, or so called holes, whose\nvalues are to be decided by an autotuner. A hole is introduced into a program\nusing the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"hole"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"hole")," takes as argument the type of the hole\n(either ",(0,r.kt)("inlineCode",{parentName:"p"},"Boolean")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"IntRange"),") and its default value. Additionally, an\n",(0,r.kt)("inlineCode",{parentName:"p"},"IntRange")," hole expects a minimum and maximum value."),(0,r.kt)("p",null,"For example, the following defines a function ",(0,r.kt)("inlineCode",{parentName:"p"},"sort")," that chooses sorting\nalgorithm based on input data length."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let sort = lam seq.\n  let threshold = hole (IntRange {default = 10, min = 0, max = 10000}) in\n  if leqi (length seq) threshold then insertionSort seq\n  else mergeSort seq\nin\n")),(0,r.kt)("p",null,"We can invoke the autotuner using the ",(0,r.kt)("inlineCode",{parentName:"p"},"mi tune")," subcommand:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mi tune sort.mc\n")),(0,r.kt)("p",null,"The autotuner uses offline profiling in order to assign the holes values such\nthat the execution time of the program is minimized. Available command-line\noptions (for setting search strategy, stopping condition, etc.) are listed in\n",(0,r.kt)("inlineCode",{parentName:"p"},"stdlib/tuning/tune-options.mc"),"."),(0,r.kt)("p",null,"The result of ",(0,r.kt)("inlineCode",{parentName:"p"},"mi tune")," is a tune file, which by default is written to\n",(0,r.kt)("inlineCode",{parentName:"p"},"sort.tune")," (if your program is called ",(0,r.kt)("inlineCode",{parentName:"p"},"sort.mc"),"). To compile the program using\nthe tuned values, invoke the main compiler with the ",(0,r.kt)("inlineCode",{parentName:"p"},"--tuned")," option:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mi compile --tuned sort.mc\n")),(0,r.kt)("p",null,"Passing the ",(0,r.kt)("inlineCode",{parentName:"p"},"--tuned")," flag to ",(0,r.kt)("inlineCode",{parentName:"p"},"mi tune")," makes the auto tuner restart the tuning\nusing the values in the tune file as start values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mi compile --tuned sort.mc\n")),(0,r.kt)("p",null,"To tune and compile the program in one go, provide the ",(0,r.kt)("inlineCode",{parentName:"p"},"--compile"),"\nflag to ",(0,r.kt)("inlineCode",{parentName:"p"},"mi tune"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mi tune --compile sort.mc\n")),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"mi compile sort.mc")," compiles the program using the default values of\nthe holes."),(0,r.kt)("h3",{id:"context-dependent-holes"},"Context-Dependent Holes"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"hole")," takes an additional (optional) parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"depth"),", which represents the\nlength of the most recent function call history that should influence the choice\nof the value of the hole. By default (if not provided), then ",(0,r.kt)("inlineCode",{parentName:"p"},"depth")," is 0, which\nmeans that the hole is assigned one value globally by the autotuner. If ",(0,r.kt)("inlineCode",{parentName:"p"},"depth"),"\nis larger than 0, then the hole is potentially assigned a different values for\neach possible context."),(0,r.kt)("p",null,"For instance, the following defines a function ",(0,r.kt)("inlineCode",{parentName:"p"},"hcreate")," that chooses between\ntwo sequence representations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let hcreate = lam n. lam f.\n  let rope = hole (Boolean {default = true, depth = 1}) in\n  (if rope then createRope else createList) n f\nin\n")),(0,r.kt)("p",null,"The hole ",(0,r.kt)("inlineCode",{parentName:"p"},"rope")," has ",(0,r.kt)("inlineCode",{parentName:"p"},"depth")," one, which means that its value might be different\nfor two different calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"hcreate"),"."),(0,r.kt)("h2",{id:"contributing"},"Contributing"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Before making a pull request please make sure that all tests pass. Run\nappropriate tests as described above.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Make sure you follow the conventions declared in the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/miking-lang/miking/wiki/Conventions"},"wiki"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We use ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ocaml-ppx/ocamlformat"},"ocamlformat")," to\nautomatically format ocaml source code."))),(0,r.kt)("h3",{id:"setup-and-use-ocamlformat"},"Setup and use ",(0,r.kt)("inlineCode",{parentName:"h3"},"ocamlformat")),(0,r.kt)("p",null,"We are currently using this package at version ",(0,r.kt)("inlineCode",{parentName:"p"},"0.24.1"),". To pin and/or install\nthe package at this version using ",(0,r.kt)("inlineCode",{parentName:"p"},"opam")," do"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"opam pin ocamlformat 0.24.1\n")),(0,r.kt)("p",null,"Then you can then run ",(0,r.kt)("inlineCode",{parentName:"p"},"dune build @fmt")," to see a\ndiff between your code and the formatted code. To promote the changes run ",(0,r.kt)("inlineCode",{parentName:"p"},"dune\npromote"),". To do these two steps in one run ",(0,r.kt)("inlineCode",{parentName:"p"},"dune build @fmt --auto-promote"),". If\nyou want to, you can run ",(0,r.kt)("inlineCode",{parentName:"p"},"ocamlformat")," in watch mode to continuously format the\nsource as you work on it with the command ",(0,r.kt)("inlineCode",{parentName:"p"},"dune build @fmt --auto-promote -w"),".\nYou can also find instructions for tighter editor integration at ",(0,r.kt)("em",{parentName:"p"},"ocamlformat's"),"\nGitHub page."),(0,r.kt)("p",null,"For convenience, ",(0,r.kt)("inlineCode",{parentName:"p"},"make lint")," will run ",(0,r.kt)("inlineCode",{parentName:"p"},"dune build @fmt")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"make fix")," will run\n",(0,r.kt)("inlineCode",{parentName:"p"},"dune build @fmt --auto-promote"),"."),(0,r.kt)("h3",{id:"git-blame"},"Git Blame"),(0,r.kt)("p",null,"Since automatic code formatting commits will obscure ",(0,r.kt)("inlineCode",{parentName:"p"},"git blame")," we maintain a\nfile  ",(0,r.kt)("a",{parentName:"p",href:".git-blame-ignore-revs"},".git-blame-ignore-revs")," that will contain the\ncommit hashes of code formatting commits. We can then run ",(0,r.kt)("inlineCode",{parentName:"p"},"git blame"),", ignoring\nthese commits as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"git blame <file(s)> --ignore-revs-file .git-blame-ignore-revs\n")),(0,r.kt)("p",null,"To make this setting persistent you can configure git like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"git config blame.ignoreRevsFile .git-blame-ignore-revs\n")),(0,r.kt)("p",null,"These instructions are adapted from\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/psf/black"},"https://github.com/psf/black"),". See\n",(0,r.kt)("a",{parentName:"p",href:"https://git-scm.com/docs/git-blame#Documentation/git-blame.txt---ignore-revltrevgt"},"https://git-scm.com/docs/git-blame#Documentation/git-blame.txt---ignore-revltrevgt"),"\nfor documentation on the ",(0,r.kt)("inlineCode",{parentName:"p"},"--ignore-revs-file")," option."),(0,r.kt)("h2",{id:"mit-license"},"MIT License"),(0,r.kt)("p",null,"Miking is licensed under the MIT license."),(0,r.kt)("p",null,"Copyright 2017-2021 David Broman"),(0,r.kt)("p",null,'Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:'),(0,r.kt)("p",null,"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software."),(0,r.kt)("p",null,'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'))}u.isMDXComponent=!0}}]);